{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Connected to base (Python 3.13.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "278f5c51-bf3a-4b2c-8500-36f2c730ca99",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting Calculations...\n",
      "Finished chunk 1 of 100, image 1 of 1\n",
      "Finished chunk 2 of 100, image 1 of 1\n",
      "Finished chunk 3 of 100, image 1 of 1\n",
      "Finished chunk 4 of 100, image 1 of 1\n",
      "Finished chunk 5 of 100, image 1 of 1\n",
      "Finished chunk 6 of 100, image 1 of 1\n",
      "Finished chunk 7 of 100, image 1 of 1\n",
      "Finished chunk 8 of 100, image 1 of 1\n",
      "Finished chunk 9 of 100, image 1 of 1\n",
      "Finished chunk 10 of 100, image 1 of 1\n",
      "Finished chunk 11 of 100, image 1 of 1\n",
      "Finished chunk 12 of 100, image 1 of 1\n",
      "Finished chunk 13 of 100, image 1 of 1\n",
      "Finished chunk 14 of 100, image 1 of 1\n",
      "Finished chunk 15 of 100, image 1 of 1\n",
      "Finished chunk 16 of 100, image 1 of 1\n",
      "Finished chunk 17 of 100, image 1 of 1\n",
      "Finished chunk 18 of 100, image 1 of 1\n",
      "Finished chunk 19 of 100, image 1 of 1\n",
      "Finished chunk 20 of 100, image 1 of 1\n",
      "Finished chunk 21 of 100, image 1 of 1\n",
      "Finished chunk 22 of 100, image 1 of 1\n",
      "Finished chunk 23 of 100, image 1 of 1\n",
      "Finished chunk 24 of 100, image 1 of 1\n",
      "Finished chunk 25 of 100, image 1 of 1\n",
      "Finished chunk 26 of 100, image 1 of 1\n",
      "Finished chunk 27 of 100, image 1 of 1\n",
      "Finished chunk 28 of 100, image 1 of 1\n",
      "Finished chunk 29 of 100, image 1 of 1\n",
      "Finished chunk 30 of 100, image 1 of 1\n",
      "Finished chunk 31 of 100, image 1 of 1\n",
      "Finished chunk 32 of 100, image 1 of 1\n",
      "Finished chunk 33 of 100, image 1 of 1\n",
      "Finished chunk 34 of 100, image 1 of 1\n",
      "Finished chunk 35 of 100, image 1 of 1\n",
      "Finished chunk 36 of 100, image 1 of 1\n",
      "Finished chunk 37 of 100, image 1 of 1\n",
      "Finished chunk 38 of 100, image 1 of 1\n",
      "Finished chunk 39 of 100, image 1 of 1\n",
      "Finished chunk 40 of 100, image 1 of 1\n",
      "Finished chunk 41 of 100, image 1 of 1\n",
      "Finished chunk 42 of 100, image 1 of 1\n",
      "Finished chunk 43 of 100, image 1 of 1\n",
      "Finished chunk 44 of 100, image 1 of 1\n",
      "Finished chunk 45 of 100, image 1 of 1\n",
      "Finished chunk 46 of 100, image 1 of 1\n",
      "Finished chunk 47 of 100, image 1 of 1\n",
      "Finished chunk 48 of 100, image 1 of 1\n",
      "Finished chunk 49 of 100, image 1 of 1\n",
      "Finished chunk 50 of 100, image 1 of 1\n",
      "Finished chunk 51 of 100, image 1 of 1\n",
      "Finished chunk 52 of 100, image 1 of 1\n",
      "Finished chunk 53 of 100, image 1 of 1\n",
      "Finished chunk 54 of 100, image 1 of 1\n",
      "Finished chunk 55 of 100, image 1 of 1\n",
      "Finished chunk 56 of 100, image 1 of 1\n",
      "Finished chunk 57 of 100, image 1 of 1\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[1], line 123\u001b[0m\n\u001b[0;32m    121\u001b[0m         y[\u001b[39m0\u001b[39m] \u001b[39m=\u001b[39m y[\u001b[39mint\u001b[39m(chunk_size \u001b[39m-\u001b[39m \u001b[39m1\u001b[39m)]\n\u001b[0;32m    122\u001b[0m         x, y \u001b[39m=\u001b[39m attractor(x, y, chunk_size, a, b, c, d)  \u001b[39m# redo the calculation for the current chunk and\u001b[39;00m\n\u001b[1;32m--> 123\u001b[0m         hist \u001b[39m+\u001b[39m\u001b[39m=\u001b[39m np\u001b[39m.\u001b[39;49mhistogram2d(x, y, bins\u001b[39m=\u001b[39;49m[image_resolution[\u001b[39m0\u001b[39;49m], image_resolution[\u001b[39m1\u001b[39;49m]])[\u001b[39m0\u001b[39m]  \u001b[39m# add the resulting histogram to the previous histogram\u001b[39;00m\n\u001b[0;32m    124\u001b[0m         \u001b[39mprint\u001b[39m(\u001b[39m'\u001b[39m\u001b[39mFinished chunk \u001b[39m\u001b[39m'\u001b[39m \u001b[39m+\u001b[39m \u001b[39mstr\u001b[39m(i \u001b[39m+\u001b[39m \u001b[39m1\u001b[39m) \u001b[39m+\u001b[39m \u001b[39m'\u001b[39m\u001b[39m of \u001b[39m\u001b[39m'\u001b[39m \u001b[39m+\u001b[39m \u001b[39mstr\u001b[39m(num_chunks) \u001b[39m+\u001b[39m \u001b[39m'\u001b[39m\u001b[39m, image \u001b[39m\u001b[39m'\u001b[39m \u001b[39m+\u001b[39m \u001b[39mstr\u001b[39m(iteration \u001b[39m+\u001b[39m \u001b[39m1\u001b[39m) \u001b[39m+\u001b[39m \u001b[39m'\u001b[39m\u001b[39m of \u001b[39m\u001b[39m'\u001b[39m \u001b[39m+\u001b[39m \u001b[39mstr\u001b[39m(images_to_make))\n\u001b[0;32m    126\u001b[0m hist \u001b[39m=\u001b[39m np\u001b[39m.\u001b[39mlog10(hist \u001b[39m+\u001b[39m \u001b[39m0.01\u001b[39m)  \u001b[39m# log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\Evan\\miniconda3\\Lib\\site-packages\\numpy\\lib\\_twodim_base_impl.py:821\u001b[0m, in \u001b[0;36mhistogram2d\u001b[1;34m(x, y, bins, range, density, weights)\u001b[0m\n\u001b[0;32m    819\u001b[0m     xedges \u001b[39m=\u001b[39m yedges \u001b[39m=\u001b[39m asarray(bins)\n\u001b[0;32m    820\u001b[0m     bins \u001b[39m=\u001b[39m [xedges, yedges]\n\u001b[1;32m--> 821\u001b[0m hist, edges \u001b[39m=\u001b[39m histogramdd([x, y], bins, \u001b[39mrange\u001b[39;49m, density, weights)\n\u001b[0;32m    822\u001b[0m \u001b[39mreturn\u001b[39;00m hist, edges[\u001b[39m0\u001b[39m], edges[\u001b[39m1\u001b[39m]\n",
      "File \u001b[1;32mc:\\Users\\Evan\\miniconda3\\Lib\\site-packages\\numpy\\lib\\_histograms_impl.py:1045\u001b[0m, in \u001b[0;36mhistogramdd\u001b[1;34m(sample, bins, range, density, weights)\u001b[0m\n\u001b[0;32m   1042\u001b[0m     dedges[i] \u001b[39m=\u001b[39m np\u001b[39m.\u001b[39mdiff(edges[i])\n\u001b[0;32m   1044\u001b[0m \u001b[39m# Compute the bin number each sample falls into.\u001b[39;00m\n\u001b[1;32m-> 1045\u001b[0m Ncount \u001b[39m=\u001b[39m \u001b[39mtuple\u001b[39;49m(\n\u001b[0;32m   1046\u001b[0m     \u001b[39m# avoid np.digitize to work around gh-11022\u001b[39;49;00m\n\u001b[0;32m   1047\u001b[0m     np\u001b[39m.\u001b[39;49msearchsorted(edges[i], sample[:, i], side\u001b[39m=\u001b[39;49m\u001b[39m'\u001b[39;49m\u001b[39mright\u001b[39;49m\u001b[39m'\u001b[39;49m)\n\u001b[0;32m   1048\u001b[0m     \u001b[39mfor\u001b[39;49;00m i \u001b[39min\u001b[39;49;00m _range(D)\n\u001b[0;32m   1049\u001b[0m )\n\u001b[0;32m   1051\u001b[0m \u001b[39m# Using digitize, values that fall on an edge are put in the right bin.\u001b[39;00m\n\u001b[0;32m   1052\u001b[0m \u001b[39m# For the rightmost bin, we want values equal to the right edge to be\u001b[39;00m\n\u001b[0;32m   1053\u001b[0m \u001b[39m# counted in the last bin, and not as an outlier.\u001b[39;00m\n\u001b[0;32m   1054\u001b[0m \u001b[39mfor\u001b[39;00m i \u001b[39min\u001b[39;00m _range(D):\n\u001b[0;32m   1055\u001b[0m     \u001b[39m# Find which points are on the rightmost edge.\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\Evan\\miniconda3\\Lib\\site-packages\\numpy\\lib\\_histograms_impl.py:1047\u001b[0m, in \u001b[0;36m<genexpr>\u001b[1;34m(.0)\u001b[0m\n\u001b[0;32m   1042\u001b[0m     dedges[i] \u001b[39m=\u001b[39m np\u001b[39m.\u001b[39mdiff(edges[i])\n\u001b[0;32m   1044\u001b[0m \u001b[39m# Compute the bin number each sample falls into.\u001b[39;00m\n\u001b[0;32m   1045\u001b[0m Ncount \u001b[39m=\u001b[39m \u001b[39mtuple\u001b[39m(\n\u001b[0;32m   1046\u001b[0m     \u001b[39m# avoid np.digitize to work around gh-11022\u001b[39;00m\n\u001b[1;32m-> 1047\u001b[0m     np\u001b[39m.\u001b[39;49msearchsorted(edges[i], sample[:, i], side\u001b[39m=\u001b[39;49m\u001b[39m'\u001b[39;49m\u001b[39mright\u001b[39;49m\u001b[39m'\u001b[39;49m)\n\u001b[0;32m   1048\u001b[0m     \u001b[39mfor\u001b[39;00m i \u001b[39min\u001b[39;00m _range(D)\n\u001b[0;32m   1049\u001b[0m )\n\u001b[0;32m   1051\u001b[0m \u001b[39m# Using digitize, values that fall on an edge are put in the right bin.\u001b[39;00m\n\u001b[0;32m   1052\u001b[0m \u001b[39m# For the rightmost bin, we want values equal to the right edge to be\u001b[39;00m\n\u001b[0;32m   1053\u001b[0m \u001b[39m# counted in the last bin, and not as an outlier.\u001b[39;00m\n\u001b[0;32m   1054\u001b[0m \u001b[39mfor\u001b[39;00m i \u001b[39min\u001b[39;00m _range(D):\n\u001b[0;32m   1055\u001b[0m     \u001b[39m# Find which points are on the rightmost edge.\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\Evan\\miniconda3\\Lib\\site-packages\\numpy\\_core\\fromnumeric.py:1527\u001b[0m, in \u001b[0;36msearchsorted\u001b[1;34m(a, v, side, sorter)\u001b[0m\n\u001b[0;32m   1447\u001b[0m \u001b[39m@array_function_dispatch\u001b[39m(_searchsorted_dispatcher)\n\u001b[0;32m   1448\u001b[0m \u001b[39mdef\u001b[39;00m\u001b[39m \u001b[39m\u001b[39msearchsorted\u001b[39m(a, v, side\u001b[39m=\u001b[39m\u001b[39m'\u001b[39m\u001b[39mleft\u001b[39m\u001b[39m'\u001b[39m, sorter\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m):\n\u001b[0;32m   1449\u001b[0m \u001b[39m    \u001b[39m\u001b[39m\"\"\"\u001b[39;00m\n\u001b[0;32m   1450\u001b[0m \u001b[39m    Find indices where elements should be inserted to maintain order.\u001b[39;00m\n\u001b[0;32m   1451\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   1525\u001b[0m \u001b[39m    30  # The element at index 2 of the sorted array is 30.\u001b[39;00m\n\u001b[0;32m   1526\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[1;32m-> 1527\u001b[0m     \u001b[39mreturn\u001b[39;00m _wrapfunc(a, \u001b[39m'\u001b[39;49m\u001b[39msearchsorted\u001b[39;49m\u001b[39m'\u001b[39;49m, v, side\u001b[39m=\u001b[39;49mside, sorter\u001b[39m=\u001b[39;49msorter)\n",
      "File \u001b[1;32mc:\\Users\\Evan\\miniconda3\\Lib\\site-packages\\numpy\\_core\\fromnumeric.py:57\u001b[0m, in \u001b[0;36m_wrapfunc\u001b[1;34m(obj, method, *args, **kwds)\u001b[0m\n\u001b[0;32m     54\u001b[0m     \u001b[39mreturn\u001b[39;00m _wrapit(obj, method, \u001b[39m*\u001b[39margs, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mkwds)\n\u001b[0;32m     56\u001b[0m \u001b[39mtry\u001b[39;00m:\n\u001b[1;32m---> 57\u001b[0m     \u001b[39mreturn\u001b[39;00m bound(\u001b[39m*\u001b[39;49margs, \u001b[39m*\u001b[39;49m\u001b[39m*\u001b[39;49mkwds)\n\u001b[0;32m     58\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mTypeError\u001b[39;00m:\n\u001b[0;32m     59\u001b[0m     \u001b[39m# A TypeError occurs if the object does have such a method in its\u001b[39;00m\n\u001b[0;32m     60\u001b[0m     \u001b[39m# class, but its signature is not identical to that of NumPy's. This\u001b[39;00m\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m     64\u001b[0m     \u001b[39m# Call _wrapit from within the except clause to ensure a potential\u001b[39;00m\n\u001b[0;32m     65\u001b[0m     \u001b[39m# exception has a traceback chain.\u001b[39;00m\n\u001b[0;32m     66\u001b[0m     \u001b[39mreturn\u001b[39;00m _wrapit(obj, method, \u001b[39m*\u001b[39margs, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mkwds)\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from scipy.ndimage import gaussian_filter\n",
    "import numpy as np\n",
    "import time\n",
    "from numba import njit\n",
    "import copy\n",
    "start_time = time.time()\n",
    "\n",
    "# This code creates pretty pictures of Peter de Jong attractors (http://paulbourke.net/fractals/peterdejong/). It's an iterative sequence, which means\n",
    "# that each value in the sequence depends on the one before it. So it's a relatively inefficient calculation, and requires some big for-loops.\n",
    "# This program works by taking a specified number of timesteps, and breaking it up into \"chunks\" of a certain size, which it then calculates \n",
    "# individually so your computer doesn't run out of RAM doing one single, massive calculation.\n",
    "\n",
    "############################################################################\n",
    "######## Interesting in playing around? This is what you care about##########\n",
    "############################################################################\n",
    "\n",
    "image_resolution = [1920, 1080]  # A standard 1080p monitor\n",
    "# image_resolution = [3840,2160]          #4K resolution. Recommended resolution for saving images.\n",
    "# image_resolution = [1125,2436]         #iPhone X resolution\n",
    "# image_resolution = [1440,3040]         #Galaxy S10 resolution\n",
    "# image_resolution = [2560,1440]         #Galaxy S8 and later (S8/9 and Note8/9 devices) resolution\n",
    "# image_resolution = [750,1334]          #iPhone 8 resolution\n",
    "# image_resolution = [1440,2560]         #Galaxy S6/S7 resolution\n",
    "# image_resolution = [3000,2400]          #High resolution 1:1\n",
    "# image_resolution = [1500,1200]          #iPad resolution\n",
    "# image_resolution = [1024,768]          #iPad mini resolution\n",
    "\n",
    "timesteps = 1e8  # 1E8 points requires ~90-140 seconds to compute on my machine, with an i5-7600k. Don't use less than 1E6 (the default chunk_size, defined below)\n",
    "# 3E6 points is good for playing around. 1E8 points is when you can no longer see a difference in image quality for 1080p resolution, IMO.\n",
    "\n",
    "randomize_values = 0  # Set to 1 to use random values for a,b,c,d\n",
    "# a = -4.733                              #Set these to whatever you want if you don't want a randomly-generated image.\n",
    "# b = 1.503\n",
    "# c = 0.682\n",
    "# d = 2.182\n",
    "a = 2.756  # Set these to whatever you want if you don't want a randomly-generated image.\n",
    "b = -1.145\n",
    "c = 0.502\n",
    "d = -4.478\n",
    "\n",
    "\n",
    "display_image = 1  # Set to 1 to display an image\n",
    "save_image = 0  # Set to 1 in order to save a copy of the displayed image in the directory where this script is located\n",
    "images_to_make = 1  # How many separate images do you want the program to produce?\n",
    "\n",
    "# ADVANCED SETTINGS\n",
    "chunk_size = 1e6  # Careful not to make this too small, or you'll run into weird things with the bounds of the 2d histogram. I recommend not changing this.\n",
    "smooth_image = 0  # Applies a tiny bit of Gaussian smoothing to the 2D histogram before plotting. Gives the image a tad more dynamic range in color and reduces \"grainy\"-ness for images with <1E9 timesteps. Disable if you want, or modify the smoothing algorithm however you want below.\n",
    "plot_scatterplot = 0  # You don't want to do this. This was just for testing purposes.\n",
    "############################################################################\n",
    "############################################################################\n",
    "############################################################################\n",
    "\n",
    "@njit(fastmath=True)                \n",
    "def attractor(x, y, num_steps, a, b, c, d):\n",
    "    for i in range(1, int(num_steps)):\n",
    "        x[i] = np.sin(a * y[i - 1]) - np.cos(b * x[i - 1])\n",
    "        y[i] = np.sin(c * x[i - 1]) - np.cos(d * y[i - 1]) \n",
    "    return x, y\n",
    "\n",
    "# This function is only used to darken an existing colormap, which I do for a few colormaps only. \n",
    "# From https://scipy-cookbook.readthedocs.io/items/Matplotlib_ColormapTransformations.html\n",
    "def cmap_map(function, cmap):\n",
    "    \"\"\" Applies function (which should operate on vectors of shape 3: [r, g, b]), on colormap cmap.\n",
    "    This routine will break any discontinuous points in a colormap.\n",
    "    \"\"\"\n",
    "    cdict = cmap._segmentdata\n",
    "    step_dict = {}\n",
    "    # Firt get the list of points where the segments start or end\n",
    "    for key in ('red', 'green', 'blue'):\n",
    "        step_dict[key] = list(map(lambda x: x[0], cdict[key]))\n",
    "    step_list = sum(step_dict.values(), [])\n",
    "    step_list = np.array(list(set(step_list)))\n",
    "    # Then compute the LUT, and apply the function to the LUT\n",
    "    def reduced_cmap(step): return np.array(cmap(step)[0:3])\n",
    "    old_LUT = np.array(list(map(reduced_cmap, step_list)))\n",
    "    new_LUT = np.array(list(map(function, old_LUT)))\n",
    "    # Now try to make a minimal segment definition of the new LUT\n",
    "    cdict = {}\n",
    "    for i, key in enumerate(['red', 'green', 'blue']):\n",
    "        this_cdict = {}\n",
    "        for j, step in enumerate(step_list):\n",
    "            if step in step_dict[key]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "            elif new_LUT[j, i] != old_LUT[j, i]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "        colorvector = list(map(lambda x: x + (x[1], ), this_cdict.items()))\n",
    "        colorvector.sort()\n",
    "        cdict[key] = colorvector\n",
    "    return matplotlib.colors.LinearSegmentedColormap('colormap', cdict, 1024)\n",
    "\n",
    "\n",
    "for iteration in range(0, images_to_make):  # complete the entire loop for as many images as you want to produce\n",
    "    plt.close('all') \n",
    "    if randomize_values == 1:\n",
    "        a = np.random.uniform(-5, 5)  # generate some random values for the variables, if that setting was chosen\n",
    "        b = np.random.uniform(-5, 5)\n",
    "        c = np.random.uniform(-5, 5)\n",
    "        d = np.random.uniform(-5, 5)\n",
    "\n",
    "    x = np.zeros(int(chunk_size))  # intialize the x/y arrays with each iteration, and set a starting value\n",
    "    y = np.zeros(int(chunk_size))\n",
    "    x[0] = 0.5  # Starting values don't matter. I'll save you the time of tinkering with them.\n",
    "    y[0] = 0.5\n",
    "\n",
    "    print('Starting Calculations...') \n",
    "    num_chunks = round(timesteps / chunk_size)  # determine the number of chunks to break the calculation into\n",
    "    x, y = attractor(x, y, chunk_size, a, b, c, d)  # calculate the values in the x/y arrays for the first chunk\n",
    "\n",
    "    # Sometimes the program will stumble onto a set of coefficients that breaks the code. This if-statement will skip that particular iteration and doesn't do any plotting/saving if that occurs\n",
    "    if (len(set(x)) == chunk_size) or (len(set(y)) == chunk_size):\n",
    "        hist = np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # make a 2D histogram with the x/y points \n",
    "        print('Finished chunk 1 of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        if timesteps > chunk_size:  # Presumably the user set timesteps > chunk_size. If the user set it equal to chunk_size, this loop gets skipped.\n",
    "            for i in range(1, num_chunks):  # Starting where the last chunk left off, do the calculation again\n",
    "                x[0] = x[int(chunk_size - 1)]  # set the initial values to the LAST values of the previous chunk\n",
    "                y[0] = y[int(chunk_size - 1)]\n",
    "                x, y = attractor(x, y, chunk_size, a, b, c, d)  # redo the calculation for the current chunk and\n",
    "                hist += np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # add the resulting histogram to the previous histogram\n",
    "                print('Finished chunk ' + str(i + 1) + ' of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        hist = np.log10(hist + 0.01)  # log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\n",
    "\n",
    "        if smooth_image == 1:  # Apply a little Gaussian smoothing algorithm\n",
    "            print('Smoothing image...')\n",
    "            hist_final = gaussian_filter(hist, 0.5, 0)\n",
    "        else:\n",
    "            hist_final = hist\n",
    "\n",
    "        end_time = time.time()\n",
    "        elapsed_time = round(end_time - start_time, 2)  # calculate the amount of time that has elapsed since program start, and print it\n",
    "        print('Elapsed Time: ' + str(elapsed_time) + ' seconds')\n",
    "\n",
    "        ### PLOTTING SECTION###       \n",
    "        if display_image == 1:\n",
    "            my_dpi = 120  # Don't change this unless you don't want your images to come out as the right size\n",
    "            fig_hist = plt.figure(figsize=(image_resolution[0] / my_dpi, image_resolution[1] / my_dpi), dpi=my_dpi, frameon=False)\n",
    "            ax = plt.Axes(fig_hist, [0., 0., 1., 1.])  # make it so the plot takes up the ENTIRE figure\n",
    "            ax.set_axis_off()\n",
    "            fig_hist.add_axes(ax)  # idk what this does\n",
    "            colormap_list = ['inferno', 'nipy_spectral', 'gnuplot2', 'hot', 'jet', 'terrain', 'gist_ncar', 'gray']  # List of colors that I think make pretty pictures. \n",
    "            colormap_list = ['Greys', 'Purples', 'Purples_r', 'Blues', 'Blues_r', 'Greens', 'Greens_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'PuRd', 'PuRd_r',\n",
    "                             'RdPu', 'RdPu_r', 'BuPu', 'BuPu_r', 'GnBu', 'GnBu_r', 'YlGnBu', 'YlGnBu_r', 'YlGn', 'YlGn_r', 'ocean', 'ocean_r']  # List of colors that I think make pretty pictures. \n",
    "            cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
    "            # cmap = cm.get_cmap('inferno')\n",
    "            # cmap = cm.get_cmap('nipy_spectral')\n",
    "            cmap = cm.get_cmap('Greys')\n",
    "            # cmap = cm.get_cmap('gnuplot2')\n",
    "            # cmap = cm.get_cmap('gist_ncar')\n",
    "            # cmap = cm.get_cmap('BuPu')\n",
    "            # cmap.set_under('Black')                                                                 #Set the lower level of the chosen color map to black.\n",
    "            hist_final = np.transpose(np.flip(hist_final, 1))  # Rotate the histogram array so that it matches the scatterplot\n",
    "            if cmap.name == 'ocean':\n",
    "                cmap.set_under('navy')\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            elif cmap.name == 'BuPu':\n",
    "                dark_cmap = cmap_map(lambda x: x * 0.75, cmap)  \n",
    "                cmap.name = 'customdark'\n",
    "                dark_cmap.set_under('black')\n",
    "                ax.imshow(hist_final, cmap=dark_cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            else:\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0000)  # Display the image\n",
    "            if save_image == 1:\n",
    "                filename = \"{:.0e}\".format(timesteps) + 'steps-' + str(round(a, 3)) + '-' + str(round(b, 3)) + '-' + str(round(c, 3)) + '-' + str(round(d, 3)) + '-' + str(cmap.name) + '.png'\n",
    "                plt.savefig(filename, format='png', dpi=my_dpi)  # save the displayed image\n",
    "\n",
    "        if plot_scatterplot == 1:\n",
    "            plt.figure(figsize=(9, 7))\n",
    "            plt.scatter(x, y, s=0.7)\n",
    "    else:\n",
    "        print('****Accidentally chose a bad set of random coefficients. Try again.****')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c71c95fd-3edb-49a8-8d66-6449f8ccaccf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting Calculations...\n",
      "Finished chunk 1 of 10, image 1 of 1\n",
      "Finished chunk 2 of 10, image 1 of 1\n",
      "Finished chunk 3 of 10, image 1 of 1\n",
      "Finished chunk 4 of 10, image 1 of 1\n",
      "Finished chunk 5 of 10, image 1 of 1\n",
      "Finished chunk 6 of 10, image 1 of 1\n",
      "Finished chunk 7 of 10, image 1 of 1\n",
      "Finished chunk 8 of 10, image 1 of 1\n",
      "Finished chunk 9 of 10, image 1 of 1\n",
      "Finished chunk 10 of 10, image 1 of 1\n",
      "Elapsed Time: 1.78 seconds\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<ipython-input-2-2b848a32de68>:148: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
      "<ipython-input-2-2b848a32de68>:151: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = cm.get_cmap('Greys')\n"
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from scipy.ndimage import gaussian_filter\n",
    "import numpy as np\n",
    "import time\n",
    "from numba import njit\n",
    "import copy\n",
    "start_time = time.time()\n",
    "\n",
    "# This code creates pretty pictures of Peter de Jong attractors (http://paulbourke.net/fractals/peterdejong/). It's an iterative sequence, which means\n",
    "# that each value in the sequence depends on the one before it. So it's a relatively inefficient calculation, and requires some big for-loops.\n",
    "# This program works by taking a specified number of timesteps, and breaking it up into \"chunks\" of a certain size, which it then calculates \n",
    "# individually so your computer doesn't run out of RAM doing one single, massive calculation.\n",
    "\n",
    "############################################################################\n",
    "######## Interesting in playing around? This is what you care about##########\n",
    "############################################################################\n",
    "\n",
    "image_resolution = [1920, 1080]  # A standard 1080p monitor\n",
    "# image_resolution = [3840,2160]          #4K resolution. Recommended resolution for saving images.\n",
    "# image_resolution = [1125,2436]         #iPhone X resolution\n",
    "# image_resolution = [1440,3040]         #Galaxy S10 resolution\n",
    "# image_resolution = [2560,1440]         #Galaxy S8 and later (S8/9 and Note8/9 devices) resolution\n",
    "# image_resolution = [750,1334]          #iPhone 8 resolution\n",
    "# image_resolution = [1440,2560]         #Galaxy S6/S7 resolution\n",
    "# image_resolution = [3000,2400]          #High resolution 1:1\n",
    "# image_resolution = [1500,1200]          #iPad resolution\n",
    "# image_resolution = [1024,768]          #iPad mini resolution\n",
    "\n",
    "timesteps = 1e7  # 1E8 points requires ~90-140 seconds to compute on my machine, with an i5-7600k. Don't use less than 1E6 (the default chunk_size, defined below)\n",
    "# 3E6 points is good for playing around. 1E8 points is when you can no longer see a difference in image quality for 1080p resolution, IMO.\n",
    "\n",
    "randomize_values = 0  # Set to 1 to use random values for a,b,c,d\n",
    "# a = -4.733                              #Set these to whatever you want if you don't want a randomly-generated image.\n",
    "# b = 1.503\n",
    "# c = 0.682\n",
    "# d = 2.182\n",
    "a = 2.756  # Set these to whatever you want if you don't want a randomly-generated image.\n",
    "b = -1.145\n",
    "c = 0.502\n",
    "d = -4.478\n",
    "\n",
    "\n",
    "display_image = 1  # Set to 1 to display an image\n",
    "save_image = 0  # Set to 1 in order to save a copy of the displayed image in the directory where this script is located\n",
    "images_to_make = 1  # How many separate images do you want the program to produce?\n",
    "\n",
    "# ADVANCED SETTINGS\n",
    "chunk_size = 1e6  # Careful not to make this too small, or you'll run into weird things with the bounds of the 2d histogram. I recommend not changing this.\n",
    "smooth_image = 0  # Applies a tiny bit of Gaussian smoothing to the 2D histogram before plotting. Gives the image a tad more dynamic range in color and reduces \"grainy\"-ness for images with <1E9 timesteps. Disable if you want, or modify the smoothing algorithm however you want below.\n",
    "plot_scatterplot = 0  # You don't want to do this. This was just for testing purposes.\n",
    "############################################################################\n",
    "############################################################################\n",
    "############################################################################\n",
    "\n",
    "@njit(fastmath=True)                \n",
    "def attractor(x, y, num_steps, a, b, c, d):\n",
    "    for i in range(1, int(num_steps)):\n",
    "        x[i] = np.sin(a * y[i - 1]) - np.cos(b * x[i - 1])\n",
    "        y[i] = np.sin(c * x[i - 1]) - np.cos(d * y[i - 1]) \n",
    "    return x, y\n",
    "\n",
    "# This function is only used to darken an existing colormap, which I do for a few colormaps only. \n",
    "# From https://scipy-cookbook.readthedocs.io/items/Matplotlib_ColormapTransformations.html\n",
    "def cmap_map(function, cmap):\n",
    "    \"\"\" Applies function (which should operate on vectors of shape 3: [r, g, b]), on colormap cmap.\n",
    "    This routine will break any discontinuous points in a colormap.\n",
    "    \"\"\"\n",
    "    cdict = cmap._segmentdata\n",
    "    step_dict = {}\n",
    "    # Firt get the list of points where the segments start or end\n",
    "    for key in ('red', 'green', 'blue'):\n",
    "        step_dict[key] = list(map(lambda x: x[0], cdict[key]))\n",
    "    step_list = sum(step_dict.values(), [])\n",
    "    step_list = np.array(list(set(step_list)))\n",
    "    # Then compute the LUT, and apply the function to the LUT\n",
    "    def reduced_cmap(step): return np.array(cmap(step)[0:3])\n",
    "    old_LUT = np.array(list(map(reduced_cmap, step_list)))\n",
    "    new_LUT = np.array(list(map(function, old_LUT)))\n",
    "    # Now try to make a minimal segment definition of the new LUT\n",
    "    cdict = {}\n",
    "    for i, key in enumerate(['red', 'green', 'blue']):\n",
    "        this_cdict = {}\n",
    "        for j, step in enumerate(step_list):\n",
    "            if step in step_dict[key]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "            elif new_LUT[j, i] != old_LUT[j, i]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "        colorvector = list(map(lambda x: x + (x[1], ), this_cdict.items()))\n",
    "        colorvector.sort()\n",
    "        cdict[key] = colorvector\n",
    "    return matplotlib.colors.LinearSegmentedColormap('colormap', cdict, 1024)\n",
    "\n",
    "\n",
    "for iteration in range(0, images_to_make):  # complete the entire loop for as many images as you want to produce\n",
    "    plt.close('all') \n",
    "    if randomize_values == 1:\n",
    "        a = np.random.uniform(-5, 5)  # generate some random values for the variables, if that setting was chosen\n",
    "        b = np.random.uniform(-5, 5)\n",
    "        c = np.random.uniform(-5, 5)\n",
    "        d = np.random.uniform(-5, 5)\n",
    "\n",
    "    x = np.zeros(int(chunk_size))  # intialize the x/y arrays with each iteration, and set a starting value\n",
    "    y = np.zeros(int(chunk_size))\n",
    "    x[0] = 0.5  # Starting values don't matter. I'll save you the time of tinkering with them.\n",
    "    y[0] = 0.5\n",
    "\n",
    "    print('Starting Calculations...') \n",
    "    num_chunks = round(timesteps / chunk_size)  # determine the number of chunks to break the calculation into\n",
    "    x, y = attractor(x, y, chunk_size, a, b, c, d)  # calculate the values in the x/y arrays for the first chunk\n",
    "\n",
    "    # Sometimes the program will stumble onto a set of coefficients that breaks the code. This if-statement will skip that particular iteration and doesn't do any plotting/saving if that occurs\n",
    "    if (len(set(x)) == chunk_size) or (len(set(y)) == chunk_size):\n",
    "        hist = np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # make a 2D histogram with the x/y points \n",
    "        print('Finished chunk 1 of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        if timesteps > chunk_size:  # Presumably the user set timesteps > chunk_size. If the user set it equal to chunk_size, this loop gets skipped.\n",
    "            for i in range(1, num_chunks):  # Starting where the last chunk left off, do the calculation again\n",
    "                x[0] = x[int(chunk_size - 1)]  # set the initial values to the LAST values of the previous chunk\n",
    "                y[0] = y[int(chunk_size - 1)]\n",
    "                x, y = attractor(x, y, chunk_size, a, b, c, d)  # redo the calculation for the current chunk and\n",
    "                hist += np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # add the resulting histogram to the previous histogram\n",
    "                print('Finished chunk ' + str(i + 1) + ' of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        hist = np.log10(hist + 0.01)  # log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\n",
    "\n",
    "        if smooth_image == 1:  # Apply a little Gaussian smoothing algorithm\n",
    "            print('Smoothing image...')\n",
    "            hist_final = gaussian_filter(hist, 0.5, 0)\n",
    "        else:\n",
    "            hist_final = hist\n",
    "\n",
    "        end_time = time.time()\n",
    "        elapsed_time = round(end_time - start_time, 2)  # calculate the amount of time that has elapsed since program start, and print it\n",
    "        print('Elapsed Time: ' + str(elapsed_time) + ' seconds')\n",
    "\n",
    "        ### PLOTTING SECTION###       \n",
    "        if display_image == 1:\n",
    "            my_dpi = 120  # Don't change this unless you don't want your images to come out as the right size\n",
    "            fig_hist = plt.figure(figsize=(image_resolution[0] / my_dpi, image_resolution[1] / my_dpi), dpi=my_dpi, frameon=False)\n",
    "            ax = plt.Axes(fig_hist, [0., 0., 1., 1.])  # make it so the plot takes up the ENTIRE figure\n",
    "            ax.set_axis_off()\n",
    "            fig_hist.add_axes(ax)  # idk what this does\n",
    "            colormap_list = ['inferno', 'nipy_spectral', 'gnuplot2', 'hot', 'jet', 'terrain', 'gist_ncar', 'gray']  # List of colors that I think make pretty pictures. \n",
    "            colormap_list = ['Greys', 'Purples', 'Purples_r', 'Blues', 'Blues_r', 'Greens', 'Greens_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'PuRd', 'PuRd_r',\n",
    "                             'RdPu', 'RdPu_r', 'BuPu', 'BuPu_r', 'GnBu', 'GnBu_r', 'YlGnBu', 'YlGnBu_r', 'YlGn', 'YlGn_r', 'ocean', 'ocean_r']  # List of colors that I think make pretty pictures. \n",
    "            cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
    "            # cmap = cm.get_cmap('inferno')\n",
    "            # cmap = cm.get_cmap('nipy_spectral')\n",
    "            cmap = cm.get_cmap('Greys')\n",
    "            # cmap = cm.get_cmap('gnuplot2')\n",
    "            # cmap = cm.get_cmap('gist_ncar')\n",
    "            # cmap = cm.get_cmap('BuPu')\n",
    "            # cmap.set_under('Black')                                                                 #Set the lower level of the chosen color map to black.\n",
    "            hist_final = np.transpose(np.flip(hist_final, 1))  # Rotate the histogram array so that it matches the scatterplot\n",
    "            if cmap.name == 'ocean':\n",
    "                cmap.set_under('navy')\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            elif cmap.name == 'BuPu':\n",
    "                dark_cmap = cmap_map(lambda x: x * 0.75, cmap)  \n",
    "                cmap.name = 'customdark'\n",
    "                dark_cmap.set_under('black')\n",
    "                ax.imshow(hist_final, cmap=dark_cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            else:\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0000)  # Display the image\n",
    "            if save_image == 1:\n",
    "                filename = \"{:.0e}\".format(timesteps) + 'steps-' + str(round(a, 3)) + '-' + str(round(b, 3)) + '-' + str(round(c, 3)) + '-' + str(round(d, 3)) + '-' + str(cmap.name) + '.png'\n",
    "                plt.savefig(filename, format='png', dpi=my_dpi)  # save the displayed image\n",
    "\n",
    "        if plot_scatterplot == 1:\n",
    "            plt.figure(figsize=(9, 7))\n",
    "            plt.scatter(x, y, s=0.7)\n",
    "    else:\n",
    "        print('****Accidentally chose a bad set of random coefficients. Try again.****')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5fd01163-0e6f-4074-854b-9afc6502a438",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting Calculations...\n",
      "Finished chunk 1 of 10, image 1 of 1\n",
      "Finished chunk 2 of 10, image 1 of 1\n",
      "Finished chunk 3 of 10, image 1 of 1\n",
      "Finished chunk 4 of 10, image 1 of 1\n",
      "Finished chunk 5 of 10, image 1 of 1\n",
      "Finished chunk 6 of 10, image 1 of 1\n",
      "Finished chunk 7 of 10, image 1 of 1\n",
      "Finished chunk 8 of 10, image 1 of 1\n",
      "Finished chunk 9 of 10, image 1 of 1\n",
      "Finished chunk 10 of 10, image 1 of 1\n",
      "Elapsed Time: 1.78 seconds\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<ipython-input-3-4558a55bc20d>:148: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
      "<ipython-input-3-4558a55bc20d>:151: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = cm.get_cmap('Greys')\n"
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from scipy.ndimage import gaussian_filter\n",
    "import numpy as np\n",
    "import time\n",
    "from numba import njit\n",
    "import copy\n",
    "start_time = time.time()\n",
    "\n",
    "# This code creates pretty pictures of Peter de Jong attractors (http://paulbourke.net/fractals/peterdejong/). It's an iterative sequence, which means\n",
    "# that each value in the sequence depends on the one before it. So it's a relatively inefficient calculation, and requires some big for-loops.\n",
    "# This program works by taking a specified number of timesteps, and breaking it up into \"chunks\" of a certain size, which it then calculates \n",
    "# individually so your computer doesn't run out of RAM doing one single, massive calculation.\n",
    "\n",
    "############################################################################\n",
    "######## Interesting in playing around? This is what you care about##########\n",
    "############################################################################\n",
    "\n",
    "image_resolution = [1920, 1080]  # A standard 1080p monitor\n",
    "# image_resolution = [3840,2160]          #4K resolution. Recommended resolution for saving images.\n",
    "# image_resolution = [1125,2436]         #iPhone X resolution\n",
    "# image_resolution = [1440,3040]         #Galaxy S10 resolution\n",
    "# image_resolution = [2560,1440]         #Galaxy S8 and later (S8/9 and Note8/9 devices) resolution\n",
    "# image_resolution = [750,1334]          #iPhone 8 resolution\n",
    "# image_resolution = [1440,2560]         #Galaxy S6/S7 resolution\n",
    "# image_resolution = [3000,2400]          #High resolution 1:1\n",
    "# image_resolution = [1500,1200]          #iPad resolution\n",
    "# image_resolution = [1024,768]          #iPad mini resolution\n",
    "\n",
    "timesteps = 1e7  # 1E8 points requires ~90-140 seconds to compute on my machine, with an i5-7600k. Don't use less than 1E6 (the default chunk_size, defined below)\n",
    "# 3E6 points is good for playing around. 1E8 points is when you can no longer see a difference in image quality for 1080p resolution, IMO.\n",
    "\n",
    "randomize_values = 0  # Set to 1 to use random values for a,b,c,d\n",
    "# a = -4.733                              #Set these to whatever you want if you don't want a randomly-generated image.\n",
    "# b = 1.503\n",
    "# c = 0.682\n",
    "# d = 2.182\n",
    "a = 2.756  # Set these to whatever you want if you don't want a randomly-generated image.\n",
    "b = -1.145\n",
    "c = 0.502\n",
    "d = -4.488\n",
    "\n",
    "\n",
    "display_image = 1  # Set to 1 to display an image\n",
    "save_image = 0  # Set to 1 in order to save a copy of the displayed image in the directory where this script is located\n",
    "images_to_make = 1  # How many separate images do you want the program to produce?\n",
    "\n",
    "# ADVANCED SETTINGS\n",
    "chunk_size = 1e6  # Careful not to make this too small, or you'll run into weird things with the bounds of the 2d histogram. I recommend not changing this.\n",
    "smooth_image = 0  # Applies a tiny bit of Gaussian smoothing to the 2D histogram before plotting. Gives the image a tad more dynamic range in color and reduces \"grainy\"-ness for images with <1E9 timesteps. Disable if you want, or modify the smoothing algorithm however you want below.\n",
    "plot_scatterplot = 0  # You don't want to do this. This was just for testing purposes.\n",
    "############################################################################\n",
    "############################################################################\n",
    "############################################################################\n",
    "\n",
    "@njit(fastmath=True)                \n",
    "def attractor(x, y, num_steps, a, b, c, d):\n",
    "    for i in range(1, int(num_steps)):\n",
    "        x[i] = np.sin(a * y[i - 1]) - np.cos(b * x[i - 1])\n",
    "        y[i] = np.sin(c * x[i - 1]) - np.cos(d * y[i - 1]) \n",
    "    return x, y\n",
    "\n",
    "# This function is only used to darken an existing colormap, which I do for a few colormaps only. \n",
    "# From https://scipy-cookbook.readthedocs.io/items/Matplotlib_ColormapTransformations.html\n",
    "def cmap_map(function, cmap):\n",
    "    \"\"\" Applies function (which should operate on vectors of shape 3: [r, g, b]), on colormap cmap.\n",
    "    This routine will break any discontinuous points in a colormap.\n",
    "    \"\"\"\n",
    "    cdict = cmap._segmentdata\n",
    "    step_dict = {}\n",
    "    # Firt get the list of points where the segments start or end\n",
    "    for key in ('red', 'green', 'blue'):\n",
    "        step_dict[key] = list(map(lambda x: x[0], cdict[key]))\n",
    "    step_list = sum(step_dict.values(), [])\n",
    "    step_list = np.array(list(set(step_list)))\n",
    "    # Then compute the LUT, and apply the function to the LUT\n",
    "    def reduced_cmap(step): return np.array(cmap(step)[0:3])\n",
    "    old_LUT = np.array(list(map(reduced_cmap, step_list)))\n",
    "    new_LUT = np.array(list(map(function, old_LUT)))\n",
    "    # Now try to make a minimal segment definition of the new LUT\n",
    "    cdict = {}\n",
    "    for i, key in enumerate(['red', 'green', 'blue']):\n",
    "        this_cdict = {}\n",
    "        for j, step in enumerate(step_list):\n",
    "            if step in step_dict[key]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "            elif new_LUT[j, i] != old_LUT[j, i]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "        colorvector = list(map(lambda x: x + (x[1], ), this_cdict.items()))\n",
    "        colorvector.sort()\n",
    "        cdict[key] = colorvector\n",
    "    return matplotlib.colors.LinearSegmentedColormap('colormap', cdict, 1024)\n",
    "\n",
    "\n",
    "for iteration in range(0, images_to_make):  # complete the entire loop for as many images as you want to produce\n",
    "    plt.close('all') \n",
    "    if randomize_values == 1:\n",
    "        a = np.random.uniform(-5, 5)  # generate some random values for the variables, if that setting was chosen\n",
    "        b = np.random.uniform(-5, 5)\n",
    "        c = np.random.uniform(-5, 5)\n",
    "        d = np.random.uniform(-5, 5)\n",
    "\n",
    "    x = np.zeros(int(chunk_size))  # intialize the x/y arrays with each iteration, and set a starting value\n",
    "    y = np.zeros(int(chunk_size))\n",
    "    x[0] = 0.5  # Starting values don't matter. I'll save you the time of tinkering with them.\n",
    "    y[0] = 0.5\n",
    "\n",
    "    print('Starting Calculations...') \n",
    "    num_chunks = round(timesteps / chunk_size)  # determine the number of chunks to break the calculation into\n",
    "    x, y = attractor(x, y, chunk_size, a, b, c, d)  # calculate the values in the x/y arrays for the first chunk\n",
    "\n",
    "    # Sometimes the program will stumble onto a set of coefficients that breaks the code. This if-statement will skip that particular iteration and doesn't do any plotting/saving if that occurs\n",
    "    if (len(set(x)) == chunk_size) or (len(set(y)) == chunk_size):\n",
    "        hist = np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # make a 2D histogram with the x/y points \n",
    "        print('Finished chunk 1 of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        if timesteps > chunk_size:  # Presumably the user set timesteps > chunk_size. If the user set it equal to chunk_size, this loop gets skipped.\n",
    "            for i in range(1, num_chunks):  # Starting where the last chunk left off, do the calculation again\n",
    "                x[0] = x[int(chunk_size - 1)]  # set the initial values to the LAST values of the previous chunk\n",
    "                y[0] = y[int(chunk_size - 1)]\n",
    "                x, y = attractor(x, y, chunk_size, a, b, c, d)  # redo the calculation for the current chunk and\n",
    "                hist += np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # add the resulting histogram to the previous histogram\n",
    "                print('Finished chunk ' + str(i + 1) + ' of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        hist = np.log10(hist + 0.01)  # log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\n",
    "\n",
    "        if smooth_image == 1:  # Apply a little Gaussian smoothing algorithm\n",
    "            print('Smoothing image...')\n",
    "            hist_final = gaussian_filter(hist, 0.5, 0)\n",
    "        else:\n",
    "            hist_final = hist\n",
    "\n",
    "        end_time = time.time()\n",
    "        elapsed_time = round(end_time - start_time, 2)  # calculate the amount of time that has elapsed since program start, and print it\n",
    "        print('Elapsed Time: ' + str(elapsed_time) + ' seconds')\n",
    "\n",
    "        ### PLOTTING SECTION###       \n",
    "        if display_image == 1:\n",
    "            my_dpi = 120  # Don't change this unless you don't want your images to come out as the right size\n",
    "            fig_hist = plt.figure(figsize=(image_resolution[0] / my_dpi, image_resolution[1] / my_dpi), dpi=my_dpi, frameon=False)\n",
    "            ax = plt.Axes(fig_hist, [0., 0., 1., 1.])  # make it so the plot takes up the ENTIRE figure\n",
    "            ax.set_axis_off()\n",
    "            fig_hist.add_axes(ax)  # idk what this does\n",
    "            colormap_list = ['inferno', 'nipy_spectral', 'gnuplot2', 'hot', 'jet', 'terrain', 'gist_ncar', 'gray']  # List of colors that I think make pretty pictures. \n",
    "            colormap_list = ['Greys', 'Purples', 'Purples_r', 'Blues', 'Blues_r', 'Greens', 'Greens_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'PuRd', 'PuRd_r',\n",
    "                             'RdPu', 'RdPu_r', 'BuPu', 'BuPu_r', 'GnBu', 'GnBu_r', 'YlGnBu', 'YlGnBu_r', 'YlGn', 'YlGn_r', 'ocean', 'ocean_r']  # List of colors that I think make pretty pictures. \n",
    "            cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
    "            # cmap = cm.get_cmap('inferno')\n",
    "            # cmap = cm.get_cmap('nipy_spectral')\n",
    "            cmap = cm.get_cmap('Greys')\n",
    "            # cmap = cm.get_cmap('gnuplot2')\n",
    "            # cmap = cm.get_cmap('gist_ncar')\n",
    "            # cmap = cm.get_cmap('BuPu')\n",
    "            # cmap.set_under('Black')                                                                 #Set the lower level of the chosen color map to black.\n",
    "            hist_final = np.transpose(np.flip(hist_final, 1))  # Rotate the histogram array so that it matches the scatterplot\n",
    "            if cmap.name == 'ocean':\n",
    "                cmap.set_under('navy')\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            elif cmap.name == 'BuPu':\n",
    "                dark_cmap = cmap_map(lambda x: x * 0.75, cmap)  \n",
    "                cmap.name = 'customdark'\n",
    "                dark_cmap.set_under('black')\n",
    "                ax.imshow(hist_final, cmap=dark_cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            else:\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0000)  # Display the image\n",
    "            if save_image == 1:\n",
    "                filename = \"{:.0e}\".format(timesteps) + 'steps-' + str(round(a, 3)) + '-' + str(round(b, 3)) + '-' + str(round(c, 3)) + '-' + str(round(d, 3)) + '-' + str(cmap.name) + '.png'\n",
    "                plt.savefig(filename, format='png', dpi=my_dpi)  # save the displayed image\n",
    "\n",
    "        if plot_scatterplot == 1:\n",
    "            plt.figure(figsize=(9, 7))\n",
    "            plt.scatter(x, y, s=0.7)\n",
    "    else:\n",
    "        print('****Accidentally chose a bad set of random coefficients. Try again.****')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5213143-eec9-42eb-b5b6-d2e917e8c3d5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting Calculations...\n",
      "Finished chunk 1 of 10, image 1 of 1\n",
      "Finished chunk 2 of 10, image 1 of 1\n",
      "Finished chunk 3 of 10, image 1 of 1\n",
      "Finished chunk 4 of 10, image 1 of 1\n",
      "Finished chunk 5 of 10, image 1 of 1\n",
      "Finished chunk 6 of 10, image 1 of 1\n",
      "Finished chunk 7 of 10, image 1 of 1\n",
      "Finished chunk 8 of 10, image 1 of 1\n",
      "Finished chunk 9 of 10, image 1 of 1\n",
      "Finished chunk 10 of 10, image 1 of 1\n",
      "Elapsed Time: 1.75 seconds\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<ipython-input-4-e703319df58b>:148: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
      "<ipython-input-4-e703319df58b>:151: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = cm.get_cmap('Greys')\n"
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from scipy.ndimage import gaussian_filter\n",
    "import numpy as np\n",
    "import time\n",
    "from numba import njit\n",
    "import copy\n",
    "start_time = time.time()\n",
    "\n",
    "# This code creates pretty pictures of Peter de Jong attractors (http://paulbourke.net/fractals/peterdejong/). It's an iterative sequence, which means\n",
    "# that each value in the sequence depends on the one before it. So it's a relatively inefficient calculation, and requires some big for-loops.\n",
    "# This program works by taking a specified number of timesteps, and breaking it up into \"chunks\" of a certain size, which it then calculates \n",
    "# individually so your computer doesn't run out of RAM doing one single, massive calculation.\n",
    "\n",
    "############################################################################\n",
    "######## Interesting in playing around? This is what you care about##########\n",
    "############################################################################\n",
    "\n",
    "image_resolution = [1920, 1080]  # A standard 1080p monitor\n",
    "# image_resolution = [3840,2160]          #4K resolution. Recommended resolution for saving images.\n",
    "# image_resolution = [1125,2436]         #iPhone X resolution\n",
    "# image_resolution = [1440,3040]         #Galaxy S10 resolution\n",
    "# image_resolution = [2560,1440]         #Galaxy S8 and later (S8/9 and Note8/9 devices) resolution\n",
    "# image_resolution = [750,1334]          #iPhone 8 resolution\n",
    "# image_resolution = [1440,2560]         #Galaxy S6/S7 resolution\n",
    "# image_resolution = [3000,2400]          #High resolution 1:1\n",
    "# image_resolution = [1500,1200]          #iPad resolution\n",
    "# image_resolution = [1024,768]          #iPad mini resolution\n",
    "\n",
    "timesteps = 1e7  # 1E8 points requires ~90-140 seconds to compute on my machine, with an i5-7600k. Don't use less than 1E6 (the default chunk_size, defined below)\n",
    "# 3E6 points is good for playing around. 1E8 points is when you can no longer see a difference in image quality for 1080p resolution, IMO.\n",
    "\n",
    "randomize_values = 0  # Set to 1 to use random values for a,b,c,d\n",
    "# a = -4.733                              #Set these to whatever you want if you don't want a randomly-generated image.\n",
    "# b = 1.503\n",
    "# c = 0.682\n",
    "# d = 2.182\n",
    "a = 2.756  # Set these to whatever you want if you don't want a randomly-generated image.\n",
    "b = -1.145\n",
    "c = 0.502\n",
    "d = -4.5\n",
    "\n",
    "\n",
    "display_image = 1  # Set to 1 to display an image\n",
    "save_image = 0  # Set to 1 in order to save a copy of the displayed image in the directory where this script is located\n",
    "images_to_make = 1  # How many separate images do you want the program to produce?\n",
    "\n",
    "# ADVANCED SETTINGS\n",
    "chunk_size = 1e6  # Careful not to make this too small, or you'll run into weird things with the bounds of the 2d histogram. I recommend not changing this.\n",
    "smooth_image = 0  # Applies a tiny bit of Gaussian smoothing to the 2D histogram before plotting. Gives the image a tad more dynamic range in color and reduces \"grainy\"-ness for images with <1E9 timesteps. Disable if you want, or modify the smoothing algorithm however you want below.\n",
    "plot_scatterplot = 0  # You don't want to do this. This was just for testing purposes.\n",
    "############################################################################\n",
    "############################################################################\n",
    "############################################################################\n",
    "\n",
    "@njit(fastmath=True)                \n",
    "def attractor(x, y, num_steps, a, b, c, d):\n",
    "    for i in range(1, int(num_steps)):\n",
    "        x[i] = np.sin(a * y[i - 1]) - np.cos(b * x[i - 1])\n",
    "        y[i] = np.sin(c * x[i - 1]) - np.cos(d * y[i - 1]) \n",
    "    return x, y\n",
    "\n",
    "# This function is only used to darken an existing colormap, which I do for a few colormaps only. \n",
    "# From https://scipy-cookbook.readthedocs.io/items/Matplotlib_ColormapTransformations.html\n",
    "def cmap_map(function, cmap):\n",
    "    \"\"\" Applies function (which should operate on vectors of shape 3: [r, g, b]), on colormap cmap.\n",
    "    This routine will break any discontinuous points in a colormap.\n",
    "    \"\"\"\n",
    "    cdict = cmap._segmentdata\n",
    "    step_dict = {}\n",
    "    # Firt get the list of points where the segments start or end\n",
    "    for key in ('red', 'green', 'blue'):\n",
    "        step_dict[key] = list(map(lambda x: x[0], cdict[key]))\n",
    "    step_list = sum(step_dict.values(), [])\n",
    "    step_list = np.array(list(set(step_list)))\n",
    "    # Then compute the LUT, and apply the function to the LUT\n",
    "    def reduced_cmap(step): return np.array(cmap(step)[0:3])\n",
    "    old_LUT = np.array(list(map(reduced_cmap, step_list)))\n",
    "    new_LUT = np.array(list(map(function, old_LUT)))\n",
    "    # Now try to make a minimal segment definition of the new LUT\n",
    "    cdict = {}\n",
    "    for i, key in enumerate(['red', 'green', 'blue']):\n",
    "        this_cdict = {}\n",
    "        for j, step in enumerate(step_list):\n",
    "            if step in step_dict[key]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "            elif new_LUT[j, i] != old_LUT[j, i]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "        colorvector = list(map(lambda x: x + (x[1], ), this_cdict.items()))\n",
    "        colorvector.sort()\n",
    "        cdict[key] = colorvector\n",
    "    return matplotlib.colors.LinearSegmentedColormap('colormap', cdict, 1024)\n",
    "\n",
    "\n",
    "for iteration in range(0, images_to_make):  # complete the entire loop for as many images as you want to produce\n",
    "    plt.close('all') \n",
    "    if randomize_values == 1:\n",
    "        a = np.random.uniform(-5, 5)  # generate some random values for the variables, if that setting was chosen\n",
    "        b = np.random.uniform(-5, 5)\n",
    "        c = np.random.uniform(-5, 5)\n",
    "        d = np.random.uniform(-5, 5)\n",
    "\n",
    "    x = np.zeros(int(chunk_size))  # intialize the x/y arrays with each iteration, and set a starting value\n",
    "    y = np.zeros(int(chunk_size))\n",
    "    x[0] = 0.5  # Starting values don't matter. I'll save you the time of tinkering with them.\n",
    "    y[0] = 0.5\n",
    "\n",
    "    print('Starting Calculations...') \n",
    "    num_chunks = round(timesteps / chunk_size)  # determine the number of chunks to break the calculation into\n",
    "    x, y = attractor(x, y, chunk_size, a, b, c, d)  # calculate the values in the x/y arrays for the first chunk\n",
    "\n",
    "    # Sometimes the program will stumble onto a set of coefficients that breaks the code. This if-statement will skip that particular iteration and doesn't do any plotting/saving if that occurs\n",
    "    if (len(set(x)) == chunk_size) or (len(set(y)) == chunk_size):\n",
    "        hist = np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # make a 2D histogram with the x/y points \n",
    "        print('Finished chunk 1 of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        if timesteps > chunk_size:  # Presumably the user set timesteps > chunk_size. If the user set it equal to chunk_size, this loop gets skipped.\n",
    "            for i in range(1, num_chunks):  # Starting where the last chunk left off, do the calculation again\n",
    "                x[0] = x[int(chunk_size - 1)]  # set the initial values to the LAST values of the previous chunk\n",
    "                y[0] = y[int(chunk_size - 1)]\n",
    "                x, y = attractor(x, y, chunk_size, a, b, c, d)  # redo the calculation for the current chunk and\n",
    "                hist += np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # add the resulting histogram to the previous histogram\n",
    "                print('Finished chunk ' + str(i + 1) + ' of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        hist = np.log10(hist + 0.01)  # log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\n",
    "\n",
    "        if smooth_image == 1:  # Apply a little Gaussian smoothing algorithm\n",
    "            print('Smoothing image...')\n",
    "            hist_final = gaussian_filter(hist, 0.5, 0)\n",
    "        else:\n",
    "            hist_final = hist\n",
    "\n",
    "        end_time = time.time()\n",
    "        elapsed_time = round(end_time - start_time, 2)  # calculate the amount of time that has elapsed since program start, and print it\n",
    "        print('Elapsed Time: ' + str(elapsed_time) + ' seconds')\n",
    "\n",
    "        ### PLOTTING SECTION###       \n",
    "        if display_image == 1:\n",
    "            my_dpi = 120  # Don't change this unless you don't want your images to come out as the right size\n",
    "            fig_hist = plt.figure(figsize=(image_resolution[0] / my_dpi, image_resolution[1] / my_dpi), dpi=my_dpi, frameon=False)\n",
    "            ax = plt.Axes(fig_hist, [0., 0., 1., 1.])  # make it so the plot takes up the ENTIRE figure\n",
    "            ax.set_axis_off()\n",
    "            fig_hist.add_axes(ax)  # idk what this does\n",
    "            colormap_list = ['inferno', 'nipy_spectral', 'gnuplot2', 'hot', 'jet', 'terrain', 'gist_ncar', 'gray']  # List of colors that I think make pretty pictures. \n",
    "            colormap_list = ['Greys', 'Purples', 'Purples_r', 'Blues', 'Blues_r', 'Greens', 'Greens_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'PuRd', 'PuRd_r',\n",
    "                             'RdPu', 'RdPu_r', 'BuPu', 'BuPu_r', 'GnBu', 'GnBu_r', 'YlGnBu', 'YlGnBu_r', 'YlGn', 'YlGn_r', 'ocean', 'ocean_r']  # List of colors that I think make pretty pictures. \n",
    "            cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
    "            # cmap = cm.get_cmap('inferno')\n",
    "            # cmap = cm.get_cmap('nipy_spectral')\n",
    "            cmap = cm.get_cmap('Greys')\n",
    "            # cmap = cm.get_cmap('gnuplot2')\n",
    "            # cmap = cm.get_cmap('gist_ncar')\n",
    "            # cmap = cm.get_cmap('BuPu')\n",
    "            # cmap.set_under('Black')                                                                 #Set the lower level of the chosen color map to black.\n",
    "            hist_final = np.transpose(np.flip(hist_final, 1))  # Rotate the histogram array so that it matches the scatterplot\n",
    "            if cmap.name == 'ocean':\n",
    "                cmap.set_under('navy')\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            elif cmap.name == 'BuPu':\n",
    "                dark_cmap = cmap_map(lambda x: x * 0.75, cmap)  \n",
    "                cmap.name = 'customdark'\n",
    "                dark_cmap.set_under('black')\n",
    "                ax.imshow(hist_final, cmap=dark_cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            else:\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0000)  # Display the image\n",
    "            if save_image == 1:\n",
    "                filename = \"{:.0e}\".format(timesteps) + 'steps-' + str(round(a, 3)) + '-' + str(round(b, 3)) + '-' + str(round(c, 3)) + '-' + str(round(d, 3)) + '-' + str(cmap.name) + '.png'\n",
    "                plt.savefig(filename, format='png', dpi=my_dpi)  # save the displayed image\n",
    "\n",
    "        if plot_scatterplot == 1:\n",
    "            plt.figure(figsize=(9, 7))\n",
    "            plt.scatter(x, y, s=0.7)\n",
    "    else:\n",
    "        print('****Accidentally chose a bad set of random coefficients. Try again.****')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "36e584cf-cf84-4e9d-a756-108446b39dde",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting Calculations...\n",
      "Finished chunk 1 of 10, image 1 of 1\n",
      "Finished chunk 2 of 10, image 1 of 1\n",
      "Finished chunk 3 of 10, image 1 of 1\n",
      "Finished chunk 4 of 10, image 1 of 1\n",
      "Finished chunk 5 of 10, image 1 of 1\n",
      "Finished chunk 6 of 10, image 1 of 1\n",
      "Finished chunk 7 of 10, image 1 of 1\n",
      "Finished chunk 8 of 10, image 1 of 1\n",
      "Finished chunk 9 of 10, image 1 of 1\n",
      "Finished chunk 10 of 10, image 1 of 1\n",
      "Elapsed Time: 1.87 seconds\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<ipython-input-5-82fd677b8643>:148: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
      "<ipython-input-5-82fd677b8643>:151: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n",
      "  cmap = cm.get_cmap('Greys')\n"
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from scipy.ndimage import gaussian_filter\n",
    "import numpy as np\n",
    "import time\n",
    "from numba import njit\n",
    "import copy\n",
    "start_time = time.time()\n",
    "\n",
    "# This code creates pretty pictures of Peter de Jong attractors (http://paulbourke.net/fractals/peterdejong/). It's an iterative sequence, which means\n",
    "# that each value in the sequence depends on the one before it. So it's a relatively inefficient calculation, and requires some big for-loops.\n",
    "# This program works by taking a specified number of timesteps, and breaking it up into \"chunks\" of a certain size, which it then calculates \n",
    "# individually so your computer doesn't run out of RAM doing one single, massive calculation.\n",
    "\n",
    "############################################################################\n",
    "######## Interesting in playing around? This is what you care about##########\n",
    "############################################################################\n",
    "\n",
    "image_resolution = [1920, 1080]  # A standard 1080p monitor\n",
    "# image_resolution = [3840,2160]          #4K resolution. Recommended resolution for saving images.\n",
    "# image_resolution = [1125,2436]         #iPhone X resolution\n",
    "# image_resolution = [1440,3040]         #Galaxy S10 resolution\n",
    "# image_resolution = [2560,1440]         #Galaxy S8 and later (S8/9 and Note8/9 devices) resolution\n",
    "# image_resolution = [750,1334]          #iPhone 8 resolution\n",
    "# image_resolution = [1440,2560]         #Galaxy S6/S7 resolution\n",
    "# image_resolution = [3000,2400]          #High resolution 1:1\n",
    "# image_resolution = [1500,1200]          #iPad resolution\n",
    "# image_resolution = [1024,768]          #iPad mini resolution\n",
    "\n",
    "timesteps = 1e7  # 1E8 points requires ~90-140 seconds to compute on my machine, with an i5-7600k. Don't use less than 1E6 (the default chunk_size, defined below)\n",
    "# 3E6 points is good for playing around. 1E8 points is when you can no longer see a difference in image quality for 1080p resolution, IMO.\n",
    "\n",
    "randomize_values = 0  # Set to 1 to use random values for a,b,c,d\n",
    "# a = -4.733                              #Set these to whatever you want if you don't want a randomly-generated image.\n",
    "# b = 1.503\n",
    "# c = 0.682\n",
    "# d = 2.182\n",
    "a = 2.756  # Set these to whatever you want if you don't want a randomly-generated image.\n",
    "b = -1.145\n",
    "c = 0.502\n",
    "d = -40.5\n",
    "\n",
    "\n",
    "display_image = 1  # Set to 1 to display an image\n",
    "save_image = 0  # Set to 1 in order to save a copy of the displayed image in the directory where this script is located\n",
    "images_to_make = 1  # How many separate images do you want the program to produce?\n",
    "\n",
    "# ADVANCED SETTINGS\n",
    "chunk_size = 1e6  # Careful not to make this too small, or you'll run into weird things with the bounds of the 2d histogram. I recommend not changing this.\n",
    "smooth_image = 0  # Applies a tiny bit of Gaussian smoothing to the 2D histogram before plotting. Gives the image a tad more dynamic range in color and reduces \"grainy\"-ness for images with <1E9 timesteps. Disable if you want, or modify the smoothing algorithm however you want below.\n",
    "plot_scatterplot = 0  # You don't want to do this. This was just for testing purposes.\n",
    "############################################################################\n",
    "############################################################################\n",
    "############################################################################\n",
    "\n",
    "@njit(fastmath=True)                \n",
    "def attractor(x, y, num_steps, a, b, c, d):\n",
    "    for i in range(1, int(num_steps)):\n",
    "        x[i] = np.sin(a * y[i - 1]) - np.cos(b * x[i - 1])\n",
    "        y[i] = np.sin(c * x[i - 1]) - np.cos(d * y[i - 1]) \n",
    "    return x, y\n",
    "\n",
    "# This function is only used to darken an existing colormap, which I do for a few colormaps only. \n",
    "# From https://scipy-cookbook.readthedocs.io/items/Matplotlib_ColormapTransformations.html\n",
    "def cmap_map(function, cmap):\n",
    "    \"\"\" Applies function (which should operate on vectors of shape 3: [r, g, b]), on colormap cmap.\n",
    "    This routine will break any discontinuous points in a colormap.\n",
    "    \"\"\"\n",
    "    cdict = cmap._segmentdata\n",
    "    step_dict = {}\n",
    "    # Firt get the list of points where the segments start or end\n",
    "    for key in ('red', 'green', 'blue'):\n",
    "        step_dict[key] = list(map(lambda x: x[0], cdict[key]))\n",
    "    step_list = sum(step_dict.values(), [])\n",
    "    step_list = np.array(list(set(step_list)))\n",
    "    # Then compute the LUT, and apply the function to the LUT\n",
    "    def reduced_cmap(step): return np.array(cmap(step)[0:3])\n",
    "    old_LUT = np.array(list(map(reduced_cmap, step_list)))\n",
    "    new_LUT = np.array(list(map(function, old_LUT)))\n",
    "    # Now try to make a minimal segment definition of the new LUT\n",
    "    cdict = {}\n",
    "    for i, key in enumerate(['red', 'green', 'blue']):\n",
    "        this_cdict = {}\n",
    "        for j, step in enumerate(step_list):\n",
    "            if step in step_dict[key]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "            elif new_LUT[j, i] != old_LUT[j, i]:\n",
    "                this_cdict[step] = new_LUT[j, i]\n",
    "        colorvector = list(map(lambda x: x + (x[1], ), this_cdict.items()))\n",
    "        colorvector.sort()\n",
    "        cdict[key] = colorvector\n",
    "    return matplotlib.colors.LinearSegmentedColormap('colormap', cdict, 1024)\n",
    "\n",
    "\n",
    "for iteration in range(0, images_to_make):  # complete the entire loop for as many images as you want to produce\n",
    "    plt.close('all') \n",
    "    if randomize_values == 1:\n",
    "        a = np.random.uniform(-5, 5)  # generate some random values for the variables, if that setting was chosen\n",
    "        b = np.random.uniform(-5, 5)\n",
    "        c = np.random.uniform(-5, 5)\n",
    "        d = np.random.uniform(-5, 5)\n",
    "\n",
    "    x = np.zeros(int(chunk_size))  # intialize the x/y arrays with each iteration, and set a starting value\n",
    "    y = np.zeros(int(chunk_size))\n",
    "    x[0] = 0.5  # Starting values don't matter. I'll save you the time of tinkering with them.\n",
    "    y[0] = 0.5\n",
    "\n",
    "    print('Starting Calculations...') \n",
    "    num_chunks = round(timesteps / chunk_size)  # determine the number of chunks to break the calculation into\n",
    "    x, y = attractor(x, y, chunk_size, a, b, c, d)  # calculate the values in the x/y arrays for the first chunk\n",
    "\n",
    "    # Sometimes the program will stumble onto a set of coefficients that breaks the code. This if-statement will skip that particular iteration and doesn't do any plotting/saving if that occurs\n",
    "    if (len(set(x)) == chunk_size) or (len(set(y)) == chunk_size):\n",
    "        hist = np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # make a 2D histogram with the x/y points \n",
    "        print('Finished chunk 1 of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        if timesteps > chunk_size:  # Presumably the user set timesteps > chunk_size. If the user set it equal to chunk_size, this loop gets skipped.\n",
    "            for i in range(1, num_chunks):  # Starting where the last chunk left off, do the calculation again\n",
    "                x[0] = x[int(chunk_size - 1)]  # set the initial values to the LAST values of the previous chunk\n",
    "                y[0] = y[int(chunk_size - 1)]\n",
    "                x, y = attractor(x, y, chunk_size, a, b, c, d)  # redo the calculation for the current chunk and\n",
    "                hist += np.histogram2d(x, y, bins=[image_resolution[0], image_resolution[1]])[0]  # add the resulting histogram to the previous histogram\n",
    "                print('Finished chunk ' + str(i + 1) + ' of ' + str(num_chunks) + ', image ' + str(iteration + 1) + ' of ' + str(images_to_make))\n",
    "\n",
    "        hist = np.log10(hist + 0.01)  # log-scale the final result, for the sake of a prettier picture. (offset is because you can't take the log of zero)\n",
    "\n",
    "        if smooth_image == 1:  # Apply a little Gaussian smoothing algorithm\n",
    "            print('Smoothing image...')\n",
    "            hist_final = gaussian_filter(hist, 0.5, 0)\n",
    "        else:\n",
    "            hist_final = hist\n",
    "\n",
    "        end_time = time.time()\n",
    "        elapsed_time = round(end_time - start_time, 2)  # calculate the amount of time that has elapsed since program start, and print it\n",
    "        print('Elapsed Time: ' + str(elapsed_time) + ' seconds')\n",
    "\n",
    "        ### PLOTTING SECTION###       \n",
    "        if display_image == 1:\n",
    "            my_dpi = 120  # Don't change this unless you don't want your images to come out as the right size\n",
    "            fig_hist = plt.figure(figsize=(image_resolution[0] / my_dpi, image_resolution[1] / my_dpi), dpi=my_dpi, frameon=False)\n",
    "            ax = plt.Axes(fig_hist, [0., 0., 1., 1.])  # make it so the plot takes up the ENTIRE figure\n",
    "            ax.set_axis_off()\n",
    "            fig_hist.add_axes(ax)  # idk what this does\n",
    "            colormap_list = ['inferno', 'nipy_spectral', 'gnuplot2', 'hot', 'jet', 'terrain', 'gist_ncar', 'gray']  # List of colors that I think make pretty pictures. \n",
    "            colormap_list = ['Greys', 'Purples', 'Purples_r', 'Blues', 'Blues_r', 'Greens', 'Greens_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'PuRd', 'PuRd_r',\n",
    "                             'RdPu', 'RdPu_r', 'BuPu', 'BuPu_r', 'GnBu', 'GnBu_r', 'YlGnBu', 'YlGnBu_r', 'YlGn', 'YlGn_r', 'ocean', 'ocean_r']  # List of colors that I think make pretty pictures. \n",
    "            cmap = copy.copy(cm.get_cmap(np.random.choice(colormap_list)))  # Pick a color from the above list at random\n",
    "            # cmap = cm.get_cmap('inferno')\n",
    "            # cmap = cm.get_cmap('nipy_spectral')\n",
    "            cmap = cm.get_cmap('Greys')\n",
    "            # cmap = cm.get_cmap('gnuplot2')\n",
    "            # cmap = cm.get_cmap('gist_ncar')\n",
    "            # cmap = cm.get_cmap('BuPu')\n",
    "            # cmap.set_under('Black')                                                                 #Set the lower level of the chosen color map to black.\n",
    "            hist_final = np.transpose(np.flip(hist_final, 1))  # Rotate the histogram array so that it matches the scatterplot\n",
    "            if cmap.name == 'ocean':\n",
    "                cmap.set_under('navy')\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            elif cmap.name == 'BuPu':\n",
    "                dark_cmap = cmap_map(lambda x: x * 0.75, cmap)  \n",
    "                cmap.name = 'customdark'\n",
    "                dark_cmap.set_under('black')\n",
    "                ax.imshow(hist_final, cmap=dark_cmap, aspect='equal', vmin=hist.min() + 0.0001)  # Display the image\n",
    "            else:\n",
    "                ax.imshow(hist_final, cmap=cmap, aspect='equal', vmin=hist.min() + 0.0000)  # Display the image\n",
    "            if save_image == 1:\n",
    "                filename = \"{:.0e}\".format(timesteps) + 'steps-' + str(round(a, 3)) + '-' + str(round(b, 3)) + '-' + str(round(c, 3)) + '-' + str(round(d, 3)) + '-' + str(cmap.name) + '.png'\n",
    "                plt.savefig(filename, format='png', dpi=my_dpi)  # save the displayed image\n",
    "\n",
    "        if plot_scatterplot == 1:\n",
    "            plt.figure(figsize=(9, 7))\n",
    "            plt.scatter(x, y, s=0.7)\n",
    "    else:\n",
    "        print('****Accidentally chose a bad set of random coefficients. Try again.****')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a55b3c9a-800d-409c-8b87-d6543ca4a764",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 1 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±10\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 1 ===\n",
      "Using coefficients: a=-1.838, b=9.408, c=-0.495, d=4.074\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.72 seconds\n",
      "Smoothing image...\n",
      "\t Chosen base colormap: jet\n",
      "Image saved to: outputs/1e+07steps--1.838-9.408--0.495-4.074-jet.png\n",
      "\n",
      "Successfully generated 1 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 1 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-1.838, 9.408, -0.495, 4.074], Colormap: jet\n",
      "     Saved as: 1e+07steps--1.838-9.408--0.495-4.074-jet.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "Inspired by the Paint-Pours project structure for ease of use.\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 1   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "randomize_coefficients = True      # Set to False to use specific values\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 10               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "smooth_image = True             # Apply Gaussian smoothing\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (if smooth_image is True)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "seed = None                        # Random seed for reproducibility (None for random)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if randomize_coefficients:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    else:\n",
    "        if coefficient_values:\n",
    "            print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "        else:\n",
    "            print(\"Using default coefficients from original script\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        randomize_coefficients=randomize_coefficients,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        smooth_image=smooth_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size,\n",
    "        seed=seed\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3209d905-ee33-49a2-a5ef-af7eeca69ce0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "De Jong Attractors - Example Usage\n",
      "==================================================\n",
      "=== Single Random Attractor ===\n",
      "Using coefficients: a=6.129, b=-0.766, c=-0.034, d=7.915\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.23 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: RdYlGn\n",
      "Image saved to: outputs/RdYlGn-1e+06steps-6.129--0.766--0.034-7.915.png\n",
      "Generated with coefficients: [6.129, -0.766, -0.034, 7.915]\n",
      "Colormap: RdYlGn\n",
      "Saved as: RdYlGn-1e+06steps-6.129--0.766--0.034-7.915.png\n",
      "\n",
      "=== Specific coefficients ===\n",
      "Using coefficients: a=2.756, b=-1.145, c=0.502, d=-4.500\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.13 seconds\n",
      "Smoothing image with sigma=0.8...\n",
      "Image saved to: outputs/inferno-1e+06steps-2.756--1.145-0.502--4.500.png\n",
      "Used exact coefficients: [2.756, -1.145, 0.502, -4.5]\n",
      "Filename: inferno-1e+06steps-2.756--1.145-0.502--4.500.png\n",
      "\n",
      "=== No Smoothing (Sharp) ===\n",
      "Using coefficients: a=6.799, b=7.619, c=9.015, d=3.842\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.15 seconds\n",
      "Image saved to: outputs/plasma-1e+06steps-6.799-7.619-9.015-3.842.png\n",
      "Sharp edges with coefficients: [6.799, 7.619, 9.015, 3.842]\n",
      "Filename: plasma-1e+06steps-6.799-7.619-9.015-3.842.png\n",
      "\n",
      "=== Batch Generation ===\n",
      "\n",
      "=== Generating image 1 of 3 ===\n",
      "Using coefficients: a=-0.052, b=1.488, c=1.105, d=2.606\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 0\n",
      "Calculation completed in 0.05 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: PuBuGn\n",
      "Image saved to: outputs/PuBuGn-5e+05steps--0.052-1.488-1.105-2.606.png\n",
      "\n",
      "=== Generating image 2 of 3 ===\n",
      "Using coefficients: a=4.360, b=-4.720, c=1.117, d=3.332\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 0\n",
      "Calculation completed in 0.06 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: cubehelix\n",
      "Image saved to: outputs/cubehelix-5e+05steps-4.360--4.720-1.117-3.332.png\n",
      "\n",
      "=== Generating image 3 of 3 ===\n",
      "Using coefficients: a=3.896, b=1.334, c=-3.390, d=0.582\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 0\n",
      "Calculation completed in 0.13 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: PuBuGn\n",
      "Image saved to: outputs/PuBuGn-5e+05steps-3.896-1.334--3.390-0.582.png\n",
      "\n",
      "Successfully generated 3 images!\n",
      "\n",
      "Generated 3 images:\n",
      "  1. PuBuGn - [-0.052, 1.488, 1.105, 2.606]\n",
      "  2. cubehelix - [4.360, -4.720, 1.117, 3.332]\n",
      "  3. PuBuGn - [3.896, 1.334, -3.390, 0.582]\n",
      "\n",
      "==================================================\n",
      "All examples completed! Check the outputs/ directory for generated images.\n",
      "You can recreate any image exactly using its coefficient values from the filename.\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Example usage of the De Jong Attractors utilities.\n",
    "\n",
    "This script demonstrates common usage patterns for the refactored\n",
    "strange attractor generation system.\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "\n",
    "def example_single_random():\n",
    "    \"\"\"Generate a single random attractor.\"\"\"\n",
    "    print(\"=== Single Random Attractor ===\")\n",
    "    \n",
    "    attractor = sa_utils.StrangeAttractor(\n",
    "        image_resolution=[800, 600],\n",
    "        timesteps=1e6,  # Quick generation\n",
    "        display_image=False,  # Don't show window\n",
    "        save_image=True\n",
    "    )\n",
    "    \n",
    "    image = attractor.generate()\n",
    "    print(f\"Generated with coefficients: [{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\")\n",
    "    print(f\"Colormap: {attractor.colormap.name}\")\n",
    "    print(f\"Saved as: {attractor.filename}\")\n",
    "    return image, attractor\n",
    "\n",
    "\n",
    "def example_specific_coefficients():\n",
    "    \"\"\"Generate an attractor with specific coefficients.\"\"\"\n",
    "    print(\"\\n=== Specific coefficients ===\")\n",
    "    \n",
    "    attractor = sa_utils.StrangeAttractor(\n",
    "        image_resolution=[800, 600],\n",
    "        timesteps=1e6,\n",
    "        coefficient_values=[2.756, -1.145, 0.502, -4.5],  # Known good coefficients\n",
    "        colormap_name='inferno',\n",
    "        gauss_smoothing=0.8,  # Extra smooth\n",
    "        display_image=False,\n",
    "        save_image=True\n",
    "    )\n",
    "    \n",
    "    image = attractor.generate()\n",
    "    print(f\"Used exact coefficients: {attractor.coefficient_values}\")\n",
    "    print(f\"Filename: {attractor.filename}\")\n",
    "    return image, attractor\n",
    "\n",
    "\n",
    "def example_no_smoothing():\n",
    "    \"\"\"Generate an attractor with no smoothing for sharp edges.\"\"\"\n",
    "    print(\"\\n=== No Smoothing (Sharp) ===\")\n",
    "    \n",
    "    attractor = sa_utils.StrangeAttractor(\n",
    "        image_resolution=[800, 600],\n",
    "        timesteps=1e6,\n",
    "        gauss_smoothing=0,  # No smoothing\n",
    "        colormap_name='plasma',\n",
    "        display_image=False,\n",
    "        save_image=True\n",
    "    )\n",
    "    \n",
    "    image = attractor.generate()\n",
    "    print(f\"Sharp edges with coefficients: [{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\")\n",
    "    print(f\"Filename: {attractor.filename}\")\n",
    "    return image, attractor\n",
    "\n",
    "\n",
    "def example_batch_generation():\n",
    "    \"\"\"Generate multiple attractors for selection.\"\"\"\n",
    "    print(\"\\n=== Batch Generation ===\")\n",
    "    \n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=3,\n",
    "        image_resolution=[600, 400],\n",
    "        timesteps=5e5,  # Very quick for demo\n",
    "        coefficient_max=5,  # Smaller range for more interesting results\n",
    "        display_image=False,\n",
    "        save_image=True\n",
    "    )\n",
    "    \n",
    "    print(f\"\\nGenerated {len(results)} images:\")\n",
    "    for i, (image, attractor) in enumerate(results, 1):\n",
    "        params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "        print(f\"  {i}. {attractor.colormap.name} - {params}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "def example_high_quality():\n",
    "    \"\"\"Generate a high quality image (this will take longer).\"\"\"\n",
    "    print(\"\\n=== High Quality Generation ===\")\n",
    "    print(\"This will take 30-60 seconds...\")\n",
    "    \n",
    "    attractor = sa_utils.StrangeAttractor(\n",
    "        image_resolution=[1920, 1080],\n",
    "        timesteps=1e7,  # High quality\n",
    "        coefficient_values=[1.234, -2.567, 0.891, -3.456],  # Interesting coefficients\n",
    "        colormap_name='viridis',\n",
    "        gauss_smoothing=0.6,\n",
    "        display_image=False,\n",
    "        save_image=True\n",
    "    )\n",
    "    \n",
    "    image = attractor.generate()\n",
    "    print(f\"High quality image saved as: {attractor.filename}\")\n",
    "    return image, attractor\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    print(\"De Jong Attractors - Example Usage\")\n",
    "    print(\"=\" * 50)\n",
    "    \n",
    "    # Run examples (comment out the high quality one if you want faster execution)\n",
    "    example_single_random()\n",
    "    example_specific_coefficients()\n",
    "    example_no_smoothing()\n",
    "    example_batch_generation()\n",
    "    \n",
    "    # Uncomment for high quality example (slower)\n",
    "    # example_high_quality()\n",
    "    \n",
    "    print(\"\\n\" + \"=\" * 50)\n",
    "    print(\"All examples completed! Check the outputs/ directory for generated images.\")\n",
    "    print(\"You can recreate any image exactly using its coefficient values from the filename.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f2dfe2c7-93c8-45af-a71e-d2f0a59cc337",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 5 image(s) at 1920x1080 resolution\n",
      "Using 1e+06 timesteps per image\n",
      "coefficients will be randomized within ±10\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 5 ===\n",
      "Using coefficients: a=4.032, b=3.075, c=7.217, d=4.437\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.21 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: plasma\n",
      "Image saved to: outputs/plasma-1e+06steps-4.032-3.075-7.217-4.437.png\n",
      "\n",
      "=== Generating image 2 of 5 ===\n",
      "Using coefficients: a=-8.063, b=0.703, c=-4.448, d=7.151\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.18 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: afmhot\n",
      "Image saved to: outputs/afmhot-1e+06steps--8.063-0.703--4.448-7.151.png\n",
      "\n",
      "=== Generating image 3 of 5 ===\n",
      "Using coefficients: a=-4.147, b=3.432, c=-8.381, d=-6.877\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.18 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Greens\n",
      "Image saved to: outputs/Greens-1e+06steps--4.147-3.432--8.381--6.877.png\n",
      "\n",
      "=== Generating image 4 of 5 ===\n",
      "Using coefficients: a=0.082, b=-9.295, c=-1.545, d=7.641\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.17 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Greens\n",
      "Image saved to: outputs/Greens-1e+06steps-0.082--9.295--1.545-7.641.png\n",
      "\n",
      "=== Generating image 5 of 5 ===\n",
      "Using coefficients: a=-7.888, b=-5.841, c=0.541, d=-4.970\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 1\n",
      "Calculation completed in 0.17 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: PuBu\n",
      "Image saved to: outputs/PuBu-1e+06steps--7.888--5.841-0.541--4.970.png\n",
      "\n",
      "Successfully generated 5 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 5 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [4.032, 3.075, 7.217, 4.437], Colormap: plasma\n",
      "     Saved as: plasma-1e+06steps-4.032-3.075-7.217-4.437.png\n",
      "  2. coefficients: [-8.063, 0.703, -4.448, 7.151], Colormap: afmhot\n",
      "     Saved as: afmhot-1e+06steps--8.063-0.703--4.448-7.151.png\n",
      "  3. coefficients: [-4.147, 3.432, -8.381, -6.877], Colormap: Greens\n",
      "     Saved as: Greens-1e+06steps--4.147-3.432--8.381--6.877.png\n",
      "  4. coefficients: [0.082, -9.295, -1.545, 7.641], Colormap: Greens\n",
      "     Saved as: Greens-1e+06steps-0.082--9.295--1.545-7.641.png\n",
      "  5. coefficients: [-7.888, -5.841, 0.541, -4.970], Colormap: PuBu\n",
      "     Saved as: PuBu-1e+06steps--7.888--5.841-0.541--4.970.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e6  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 5   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 10               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "360cef90-9a36-472e-be25-580d458c0522",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 5 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±10\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 5 ===\n",
      "Using coefficients: a=-7.579, b=4.420, c=-2.834, d=-5.112\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.70 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Oranges\n",
      "Image saved to: outputs/Oranges-1e+07steps--7.579-4.420--2.834--5.112.png\n",
      "\n",
      "=== Generating image 2 of 5 ===\n",
      "Using coefficients: a=5.198, b=-8.120, c=6.030, d=0.284\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.63 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: BuPu\n",
      "Image saved to: outputs/BuPu_darkened-1e+07steps-5.198--8.120-6.030-0.284.png\n",
      "\n",
      "=== Generating image 3 of 5 ===\n",
      "Using coefficients: a=-1.288, b=7.883, c=6.510, d=-5.651\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.62 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: gist_earth\n",
      "Image saved to: outputs/gist_earth-1e+07steps--1.288-7.883-6.510--5.651.png\n",
      "\n",
      "=== Generating image 4 of 5 ===\n",
      "Using coefficients: a=5.379, b=9.655, c=-4.839, d=-7.852\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.72 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Purples\n",
      "Image saved to: outputs/Purples-1e+07steps-5.379-9.655--4.839--7.852.png\n",
      "\n",
      "=== Generating image 5 of 5 ===\n",
      "Using coefficients: a=-2.677, b=2.561, c=5.072, d=-5.897\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.68 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Grays\n",
      "Image saved to: outputs/Grays-1e+07steps--2.677-2.561-5.072--5.897.png\n",
      "\n",
      "Successfully generated 5 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 5 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-7.579, 4.420, -2.834, -5.112], Colormap: Oranges\n",
      "     Saved as: Oranges-1e+07steps--7.579-4.420--2.834--5.112.png\n",
      "  2. coefficients: [5.198, -8.120, 6.030, 0.284], Colormap: BuPu_darkened\n",
      "     Saved as: BuPu_darkened-1e+07steps-5.198--8.120-6.030-0.284.png\n",
      "  3. coefficients: [-1.288, 7.883, 6.510, -5.651], Colormap: gist_earth\n",
      "     Saved as: gist_earth-1e+07steps--1.288-7.883-6.510--5.651.png\n",
      "  4. coefficients: [5.379, 9.655, -4.839, -7.852], Colormap: Purples\n",
      "     Saved as: Purples-1e+07steps-5.379-9.655--4.839--7.852.png\n",
      "  5. coefficients: [-2.677, 2.561, 5.072, -5.897], Colormap: Grays\n",
      "     Saved as: Grays-1e+07steps--2.677-2.561-5.072--5.897.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 5   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 10               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5c230e80-b1f2-47b7-9ac1-0f0ff94bdd97",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 1 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±1\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 1 ===\n",
      "Using coefficients: a=-0.182, b=0.063, c=0.858, d=0.591\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.63 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: coolwarm\n",
      "Image saved to: outputs/coolwarm-1e+07steps--0.182-0.063-0.858-0.591.png\n",
      "\n",
      "Successfully generated 1 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 1 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-0.182, 0.063, 0.858, 0.591], Colormap: coolwarm\n",
      "     Saved as: coolwarm-1e+07steps--0.182-0.063-0.858-0.591.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 1   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 1               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = False               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0329d18d-95be-4c42-add8-769a14cd5476",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 1 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±1\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 1 ===\n",
      "Using coefficients: a=-0.262, b=-0.547, c=0.569, d=-0.842\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.51 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Spectral\n",
      "Image saved to: outputs/Spectral-1e+07steps--0.262--0.547-0.569--0.842.png\n",
      "\n",
      "Successfully generated 1 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 1 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-0.262, -0.547, 0.569, -0.842], Colormap: Spectral\n",
      "     Saved as: Spectral-1e+07steps--0.262--0.547-0.569--0.842.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 1   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 1               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "89976afc-9d56-42c8-828f-d34ba5950a47",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 1 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±1\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 1 ===\n",
      "Using coefficients: a=-0.124, b=0.403, c=0.606, d=-0.319\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.45 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: PiYG\n",
      "Image saved to: outputs/PiYG-1e+07steps--0.124-0.403-0.606--0.319.png\n",
      "\n",
      "Successfully generated 1 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 1 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-0.124, 0.403, 0.606, -0.319], Colormap: PiYG\n",
      "     Saved as: PiYG-1e+07steps--0.124-0.403-0.606--0.319.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 1   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 1               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "db2cb3c0-5411-4c13-805c-d9e648d0cc99",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 1 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±1\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 1 ===\n",
      "Using coefficients: a=0.321, b=0.668, c=-0.191, d=-0.453\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.46 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: PuOr\n",
      "Image saved to: outputs/PuOr-1e+07steps-0.321-0.668--0.191--0.453.png\n",
      "\n",
      "Successfully generated 1 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 1 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [0.321, 0.668, -0.191, -0.453], Colormap: PuOr\n",
      "     Saved as: PuOr-1e+07steps-0.321-0.668--0.191--0.453.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 1   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 1               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "401f709f-604d-498e-9191-8675231f768b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 5 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±1\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 5 ===\n",
      "Using coefficients: a=-0.657, b=0.958, c=-0.988, d=-0.872\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.71 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: bone\n",
      "Image saved to: outputs/bone-1e+07steps--0.657-0.958--0.988--0.872.png\n",
      "\n",
      "=== Generating image 2 of 5 ===\n",
      "Using coefficients: a=-0.254, b=-0.809, c=-0.481, d=0.835\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.66 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: RdYlBu\n",
      "Image saved to: outputs/RdYlBu-1e+07steps--0.254--0.809--0.481-0.835.png\n",
      "\n",
      "=== Generating image 3 of 5 ===\n",
      "Using coefficients: a=-0.386, b=0.875, c=-0.304, d=-0.457\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.51 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: seismic\n",
      "Image saved to: outputs/seismic-1e+07steps--0.386-0.875--0.304--0.457.png\n",
      "\n",
      "=== Generating image 4 of 5 ===\n",
      "Using coefficients: a=0.584, b=0.236, c=-0.051, d=0.159\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.48 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: vanimo\n",
      "Image saved to: outputs/vanimo-1e+07steps-0.584-0.236--0.051-0.159.png\n",
      "\n",
      "=== Generating image 5 of 5 ===\n",
      "Using coefficients: a=-0.457, b=0.487, c=-0.614, d=-0.045\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.48 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Spectral\n",
      "Image saved to: outputs/Spectral-1e+07steps--0.457-0.487--0.614--0.045.png\n",
      "\n",
      "Successfully generated 5 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 5 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-0.657, 0.958, -0.988, -0.872], Colormap: bone\n",
      "     Saved as: bone-1e+07steps--0.657-0.958--0.988--0.872.png\n",
      "  2. coefficients: [-0.254, -0.809, -0.481, 0.835], Colormap: RdYlBu\n",
      "     Saved as: RdYlBu-1e+07steps--0.254--0.809--0.481-0.835.png\n",
      "  3. coefficients: [-0.386, 0.875, -0.304, -0.457], Colormap: seismic\n",
      "     Saved as: seismic-1e+07steps--0.386-0.875--0.304--0.457.png\n",
      "  4. coefficients: [0.584, 0.236, -0.051, 0.159], Colormap: vanimo\n",
      "     Saved as: vanimo-1e+07steps-0.584-0.236--0.051-0.159.png\n",
      "  5. coefficients: [-0.457, 0.487, -0.614, -0.045], Colormap: Spectral\n",
      "     Saved as: Spectral-1e+07steps--0.457-0.487--0.614--0.045.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 5   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 1               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e1be657e-0d1c-4ce6-86b4-42c8f4458c96",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 5 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±10\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 5 ===\n",
      "Using coefficients: a=-8.250, b=1.272, c=-2.252, d=-6.499\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.65 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: cubehelix\n",
      "Image saved to: outputs/cubehelix-1e+07steps--8.250-1.272--2.252--6.499.png\n",
      "\n",
      "=== Generating image 2 of 5 ===\n",
      "Using coefficients: a=1.171, b=8.907, c=9.522, d=7.002\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.73 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: viridis\n",
      "Image saved to: outputs/viridis-1e+07steps-1.171-8.907-9.522-7.002.png\n",
      "\n",
      "=== Generating image 3 of 5 ===\n",
      "Using coefficients: a=8.778, b=2.896, c=-8.552, d=-7.620\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.64 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: summer\n",
      "Image saved to: outputs/summer-1e+07steps-8.778-2.896--8.552--7.620.png\n",
      "\n",
      "=== Generating image 4 of 5 ===\n",
      "Using coefficients: a=5.574, b=8.572, c=-0.259, d=6.457\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 1.64 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: Spectral\n",
      "Image saved to: outputs/Spectral-1e+07steps-5.574-8.572--0.259-6.457.png\n",
      "\n",
      "=== Generating image 5 of 5 ===\n",
      "Using coefficients: a=0.093, b=1.116, c=-2.047, d=-5.168\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Calculation completed in 0.71 seconds\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: winter\n",
      "Image saved to: outputs/winter-1e+07steps-0.093-1.116--2.047--5.168.png\n",
      "\n",
      "Successfully generated 5 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 5 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-8.250, 1.272, -2.252, -6.499], Colormap: cubehelix\n",
      "     Saved as: cubehelix-1e+07steps--8.250-1.272--2.252--6.499.png\n",
      "  2. coefficients: [1.171, 8.907, 9.522, 7.002], Colormap: viridis\n",
      "     Saved as: viridis-1e+07steps-1.171-8.907-9.522-7.002.png\n",
      "  3. coefficients: [8.778, 2.896, -8.552, -7.620], Colormap: summer\n",
      "     Saved as: summer-1e+07steps-8.778-2.896--8.552--7.620.png\n",
      "  4. coefficients: [5.574, 8.572, -0.259, 6.457], Colormap: Spectral\n",
      "     Saved as: Spectral-1e+07steps-5.574-8.572--0.259-6.457.png\n",
      "  5. coefficients: [0.093, 1.116, -2.047, -5.168], Colormap: winter\n",
      "     Saved as: winter-1e+07steps-0.093-1.116--2.047--5.168.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 5   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 10               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a3f77135-3fe9-40a6-b924-366dd08ea39c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Strange Attractor Generator\n",
      "==================================================\n",
      "Generating 5 image(s) at 1920x1080 resolution\n",
      "Using 1e+07 timesteps per image\n",
      "coefficients will be randomized within ±10\n",
      "Gaussian smoothing: 0.5\n",
      "--------------------------------------------------\n",
      "\n",
      "=== Generating image 1 of 5 ===\n",
      "Using coefficients: a=-3.898, b=-1.094, c=-0.657, d=7.902\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: autumn\n",
      "Image saved to: outputs/autumn-1e+07steps--3.898--1.094--0.657-7.902.png\n",
      "Calculation completed in 2.25 seconds\n",
      "\n",
      "=== Generating image 2 of 5 ===\n",
      "Using coefficients: a=5.013, b=-4.121, c=-2.485, d=8.013\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: cividis\n",
      "Image saved to: outputs/cividis-1e+07steps-5.013--4.121--2.485-8.013.png\n",
      "Calculation completed in 2.57 seconds\n",
      "\n",
      "=== Generating image 3 of 5 ===\n",
      "Using coefficients: a=-7.682, b=-5.043, c=-8.869, d=-3.088\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: berlin\n",
      "Image saved to: outputs/berlin-1e+07steps--7.682--5.043--8.869--3.088.png\n",
      "Calculation completed in 2.50 seconds\n",
      "\n",
      "=== Generating image 4 of 5 ===\n",
      "Using coefficients: a=0.109, b=7.325, c=-0.001, d=4.735\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: seismic\n",
      "Image saved to: outputs/seismic-1e+07steps-0.109-7.325--0.001-4.735.png\n",
      "Calculation completed in 1.47 seconds\n",
      "\n",
      "=== Generating image 5 of 5 ===\n",
      "Using coefficients: a=3.753, b=-4.703, c=-5.422, d=-2.946\n",
      "Starting calculations...\n",
      "Finished chunk 1 of 10\n",
      "Finished chunk 2 of 10\n",
      "Finished chunk 3 of 10\n",
      "Finished chunk 4 of 10\n",
      "Finished chunk 5 of 10\n",
      "Finished chunk 6 of 10\n",
      "Finished chunk 7 of 10\n",
      "Finished chunk 8 of 10\n",
      "Finished chunk 9 of 10\n",
      "Finished chunk 10 of 10\n",
      "Smoothing image with sigma=0.5...\n",
      "\t Chosen base colormap: ocean\n",
      "Image saved to: outputs/ocean-1e+07steps-3.753--4.703--5.422--2.946.png\n",
      "Calculation completed in 2.55 seconds\n",
      "\n",
      "Successfully generated 5 images!\n",
      "==================================================\n",
      "Generation complete! Successfully created 5 images.\n",
      "\n",
      "Generated images:\n",
      "  1. coefficients: [-3.898, -1.094, -0.657, 7.902], Colormap: autumn\n",
      "     Saved as: autumn-1e+07steps--3.898--1.094--0.657-7.902.png\n",
      "  2. coefficients: [5.013, -4.121, -2.485, 8.013], Colormap: cividis\n",
      "     Saved as: cividis-1e+07steps-5.013--4.121--2.485-8.013.png\n",
      "  3. coefficients: [-7.682, -5.043, -8.869, -3.088], Colormap: berlin\n",
      "     Saved as: berlin-1e+07steps--7.682--5.043--8.869--3.088.png\n",
      "  4. coefficients: [0.109, 7.325, -0.001, 4.735], Colormap: seismic\n",
      "     Saved as: seismic-1e+07steps-0.109-7.325--0.001-4.735.png\n",
      "  5. coefficients: [3.753, -4.703, -5.422, -2.946], Colormap: ocean\n",
      "     Saved as: ocean-1e+07steps-3.753--4.703--5.422--2.946.png\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Strange Attractor Sandbox\n",
    "\n",
    "A user-friendly script for generating Peter de Jong strange attractor images.\n",
    "This script allows you to easily specify coefficients and generate multiple images.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import strange_attractor_utilities as sa_utils\n",
    "import matplotlib\n",
    "\n",
    "# Set the matplotlib backend (adjust if needed for your system)\n",
    "# Common options: 'QtAgg', 'TkAgg', 'Agg' (for headless)\n",
    "matplotlib.use('QtAgg')\n",
    "\n",
    "# ######## USER-DEFINED VARIABLES #########\n",
    "\n",
    "# Image settings\n",
    "image_resolution = [1920, 1080]  # [width, height] in pixels\n",
    "# Other common resolutions:\n",
    "# image_resolution = [3840, 2160]   # 4K resolution\n",
    "# image_resolution = [1125, 2436]   # iPhone X resolution\n",
    "# image_resolution = [1440, 3040]   # Galaxy S10 resolution\n",
    "# image_resolution = [2560, 1440]   # 2K resolution\n",
    "# image_resolution = [1500, 1200]   # iPad resolution\n",
    "\n",
    "# Generation settings\n",
    "timesteps = 1e7  # Number of points to calculate (1E8 for highest quality, 3E6 for quick testing)\n",
    "num_images = 5   # How many separate images to generate\n",
    "\n",
    "# coefficient settings\n",
    "coefficient_values = None          # Specific [a, b, c, d] values (set to None for random)\n",
    "# coefficient_values = [2.756, -1.145, 0.502, -4.5]  # Example specific values\n",
    "coefficient_max = 10               # Maximum absolute value for random coefficients\n",
    "\n",
    "# Output settings\n",
    "output_directory = 'outputs/'    # Where to save images\n",
    "save_image = True               # Save images to disk\n",
    "display_image = True               # Display images on screen\n",
    "\n",
    "# Visual settings\n",
    "gauss_smoothing = 0.5          # Standard deviation for smoothing (set to 0 for no smoothing)\n",
    "colormap_name = None           # Specific colormap name (None for random selection)\n",
    "# colormap_name = 'inferno'     # Example: use a specific colormap\n",
    "\n",
    "# Advanced settings\n",
    "show_troubleshooting_plots = False  # Show intermediate plots for debugging\n",
    "chunk_size = 1e6                   # Memory management (don't change unless needed)\n",
    "\n",
    "# ######## GENERATION CODE #########\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main function to generate the strange attractor images.\"\"\"\n",
    "    \n",
    "    print(\"Strange Attractor Generator\")\n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generating {num_images} image(s) at {image_resolution[0]}x{image_resolution[1]} resolution\")\n",
    "    print(f\"Using {timesteps:.0e} timesteps per image\")\n",
    "    if coefficient_values:\n",
    "        print(f\"Using fixed coefficients: {coefficient_values}\")\n",
    "    else:\n",
    "        print(f\"coefficients will be randomized within ±{coefficient_max}\")\n",
    "    if gauss_smoothing > 0:\n",
    "        print(f\"Gaussian smoothing: {gauss_smoothing}\")\n",
    "    else:\n",
    "        print(\"No smoothing (sharp edges)\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    # Generate images\n",
    "    results = sa_utils.generate_strange_attractor_images(\n",
    "        num_images=num_images,\n",
    "        image_resolution=image_resolution,\n",
    "        timesteps=timesteps,\n",
    "        coefficient_values=coefficient_values,\n",
    "        coefficient_max=coefficient_max,\n",
    "        output_directory=output_directory,\n",
    "        show_troubleshooting_plots=show_troubleshooting_plots,\n",
    "        display_image=display_image,\n",
    "        save_image=save_image,\n",
    "        gauss_smoothing=gauss_smoothing,\n",
    "        colormap_name=colormap_name,\n",
    "        chunk_size=chunk_size\n",
    "    )\n",
    "    \n",
    "    print(\"=\" * 50)\n",
    "    print(f\"Generation complete! Successfully created {len(results)} images.\")\n",
    "    \n",
    "    # Print summary of generated images\n",
    "    if results:\n",
    "        print(\"\\nGenerated images:\")\n",
    "        for i, (image, attractor) in enumerate(results, 1):\n",
    "            params = f\"[{attractor.a:.3f}, {attractor.b:.3f}, {attractor.c:.3f}, {attractor.d:.3f}]\"\n",
    "            colormap = attractor.colormap.name if attractor.colormap else \"unknown\"\n",
    "            filename = attractor.filename if attractor.filename else \"not saved\"\n",
    "            print(f\"  {i}. coefficients: {params}, Colormap: {colormap}\")\n",
    "            if save_image:\n",
    "                print(f\"     Saved as: {filename}\")\n",
    "    \n",
    "    return results\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    results = main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
